<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Multithreading</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark-href {
	font-size: 0.75em;
	opacity: 0.5;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, KaiTi, STKaiTi, 'ÂçéÊñáÊ•∑‰Ωì', KaiTi_GB2312, 'Ê•∑‰Ωì_GB2312', serif; }
.mono { font-family: Nitti, 'Microsoft YaHei', 'ÂæÆËΩØÈõÖÈªë', monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, KaiTi, STKaiTi, 'ÂçéÊñáÊ•∑‰Ωì', KaiTi_GB2312, 'Ê•∑‰Ωì_GB2312', serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, Nitti, 'Microsoft YaHei', 'ÂæÆËΩØÈõÖÈªë', monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="6081d956-dabc-43ad-95c5-7aa9eaced001" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">üîÄ</span></div><h1 class="page-title">Multithreading</h1><table class="properties"><tbody><tr class="property-row property-row-select"><th>Category</th><td><span class="selected-value">System</span></td></tr></tbody></table></header><div class="page-body"><nav id="86ed2478-b4c3-41a0-b0d8-fb2f118fe3b2" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f84193a0-37bb-4702-a1f1-2ece1ac5bcff">Overview</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#cb70242c-c0bf-4139-902b-876f166e538a">Goals</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#76d2636e-12fa-432d-85c8-0cb565ac2722">Threads</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#57b40ae0-2d74-4d73-a0ab-dcc2713fe50b">Hardware thread</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#90c12092-118c-4de0-ac48-c6d1f58a272d">Software thread</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#25a5f23c-5518-4eec-9fcd-22b9a688a13b">Scheduler</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6fb07c5d-7728-4be3-a82f-d67e04ac2bb7">Simultaneous Multi-Threading</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b2ad0897-2016-41af-93da-575f1239ab80">Synchronization</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e1577eab-6250-4192-9ae2-ab25543e60b5">Synchronization Primitives</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#63846d79-287c-4985-9614-9621f701d861">Mutexes</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#179e7363-746f-4c8c-852e-4450aba57263">Critical Sections</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2a86f712-0df7-406d-820f-01f416793472">Semaphores</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#38ed71ec-f610-4ee6-9b19-eb53926acc4d">Events</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ddf8e0de-0c3a-4c63-9c76-f884905169fb">Timers</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2acddaca-676e-4dfa-a9d5-dd4b6135ef1f">Examples</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#436d27c6-85f6-45f9-a01c-c51b7f8c9c0d">Locking</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#73c406bd-6496-4184-a26a-f9f2c65e2c83">Atomics</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#115ba022-9c62-4383-a93e-bcf82e4fd030">Volatile Variables and Reordering</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#489273ab-4e10-49c4-b818-bce78b613d4d">Deadlock</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e8d42c3f-b260-4092-8872-cb34ed685eab">Priority Inversion</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9e6a235a-9375-4fed-a207-e93aaf3b8e4c">Managing Threads</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e3e7ea3c-b1b9-4f4e-8dba-fa515bdb43d2">Fibers</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#12217c48-44f9-4e8f-a90f-c8bd779ede4d">Multithreading architectures</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#79366c15-06ce-491d-9c4b-143e54aa9f9f">Pipeline</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3187baba-8565-49a8-bf56-8e593d396489">Contractor queue</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ab4add3f-1866-4fc3-8d0a-23223c161c35">Work crew</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e1090f56-c3e9-475a-97e8-942d1b738211">Synchronization Examples</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c2bf4b8c-ed7b-410f-937e-a66723a12a8a">Exclusive Access</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#65b74b2f-dc7f-4f0b-a94a-2dd5a0f95870">Mutex</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#e8b7658d-a167-47f8-b249-7c8eaf2f8570">Critical section</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#ab995d23-9561-4357-a60f-53b83cfbb4e4">Events</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#5c7a30a0-c167-49bc-a6df-c47066d58e3a">Semaphores</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e10a6549-54c8-4ae9-a46a-501c678de8e2">Lockless Programming</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c4bca2f3-bbca-41e7-920e-d56730718cb3">Lockless Containers</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#61002d61-e983-4c95-b8c8-40837fc1a81c">Lock-free Stack</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#672a8982-ad06-444d-af1f-a5acbe48ffe4">Lock-free Queue</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#8dcafb7c-2776-4b6c-956c-b1779d216306">Lock-free Priority Queue</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#68101bcf-1e1d-44d2-8c66-ebb6c3e76a1e">Lock-free Hash Table</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ca8c33f2-af23-4fe1-9d6d-41f6ac48848f">Logging</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e281e2b6-5f1b-4978-96f5-1f08695d4119">Best Practices</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#366785cc-c6b6-4177-929a-0bae6063c5dd">Synchronization</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fdc3b0dd-abe3-4a18-92f6-7860db1cf275">Scheduling Priorities</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#be216cdf-8884-4a8c-b646-e40b88e773e0">Thread Local Storage</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#428dd9f7-977f-4f21-b69c-f83faf2a03d1">TLS Storage</a></div><div class="table_of_contents-item table_of_contents-indent-2"><a class="table_of_contents-link" href="#18bfb544-7057-4a67-b696-6a1d9a17db4e">TLS Variable</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e5973cab-d102-43a4-a589-8b851522afc9">Timing</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#35e1722e-9fad-47a7-9b03-bc0c100c6f37">Debugging</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f6f659fe-b7c4-4dfa-8831-ac43cfc509d2">Use Cases</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a20a5c9b-fd7d-400e-a768-96ce14a66959">Loading</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f6a9c26a-d130-42e8-aedc-9702afc9e26c">Rendering</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a9ddb2e2-fdc4-4208-a328-12afe22b90df">Physics and Animation</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9a779f34-6a38-4c15-b93b-c7591c369dd7">Optional Simulations</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#90982925-70a0-438c-a3dd-cb5f2ac678d0">Worker threads</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ed069d3e-0c69-4ee8-a5c7-de629398b247">References</a></div></nav><hr id="841e2d98-29e8-4aa2-b73e-51085ed49ab9"/><h1 id="f84193a0-37bb-4702-a1f1-2ece1ac5bcff" class="">Overview</h1><p id="84f87064-1356-4d16-81c2-b60420c2ba0d" class="">The performance of single processor cores is now increasing very slowly.</p><p id="d3bcdb7e-a8fb-4d27-ac82-354789af2c00" class="">However, the computing power available is growing by having multiple processor cores in a single machine.</p><p id="b9dd4ca3-e52d-494d-89b8-5486f3ad9ae5" class="">Developers have to write multithreaded code in order to use this power.</p><p id="be6a9656-dbd0-4045-a097-fcb23af90f3f" class="">Multi-threaded programming brings new design and programming challenges.</p><h1 id="cb70242c-c0bf-4139-902b-876f166e538a" class="">Goals</h1><p id="4325587e-4360-404d-9353-d3d039c20227" class="">The simplest design goal for multithreading is to break up the code into large independent pieces and restrict these pieces to communicating just a few times per frame.</p><h1 id="76d2636e-12fa-432d-85c8-0cb565ac2722" class="">Threads</h1><p id="d67b6946-b6b5-46d0-b330-84c47dd7270c" class="">Each program in the operating system is a process.</p><p id="9fd2ba29-dcc4-440c-abe5-0aa1653792fa" class="">A process starts with a single thread, called the <em>primary thread</em>.</p><p id="8c8ced36-e1c4-432e-91db-21fbe45489e2" class="">Additional threads can be created by the operating system.</p><p id="18ad6860-d5fb-4f09-bf2f-a8da77cce608" class="">All threads share the process&#x27;s virtual address space and system resources.</p><h2 id="57b40ae0-2d74-4d73-a0ab-dcc2713fe50b" class="">Hardware thread</h2><p id="c914444e-54a8-4a3d-927c-5df180028a17" class="">A <em>hardware thread</em> is a physical CPU&#x27;s core.</p><p id="753293d1-98ff-4f96-9562-b1cfd4093a7a" class="">For example, in a quad-core CPU architecture, four hardware threads are supported at once and the CPU is really doing four things at the same time.</p><p id="06848d3d-c843-491f-b4ad-53df06b3ade8" class="">Each hardware thread has its own stack and set of registers.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="7b487ff2-9358-4f28-9245-b3c90b9b30b0"><div style="font-size:1.5em"><span class="icon">üéÆ</span></div><div style="width:100%">On Xbox, each thread has a default stack size of 64-KB.</div></figure><h2 id="90c12092-118c-4de0-ac48-c6d1f58a272d" class="">Software thread</h2><p id="50b251c4-d604-4056-bfe4-7ec7412cdff7" class="">A <em>software thread</em> is managed by the operating system&#x27;s kernel.</p><p id="1ea2d71b-ff9c-495a-a2b7-5a6f7c0bcc10" class="">A hardware thread can run many software threads.</p><p id="ade8bbc5-2e97-406b-9d6a-5b9b057287e1" class="">The CPU time is divided among those threads.</p><p id="aaac25cd-2238-4a46-8d08-44b7b1d614d3" class=""><em>Preemptive multitasking</em> takes place on each processor.</p><p id="08243417-d441-4a6a-a199-5068acd2588c" class="">Preemptive multitasking means that while a thread is executing, the kernel can interrupt it to schedule another thread (of equal or higher priority) for execution.</p><p id="061b21eb-34ad-4f2a-9467-6b0cc1e4ec1d" class="">Each software thread maintains a set of structures the system will use to save the thread context until it is scheduled. The thread context includes the thread&#x27;s stack and set of registers.</p><h1 id="25a5f23c-5518-4eec-9fcd-22b9a688a13b" class="">Scheduler</h1><p id="136f9edc-1012-42bd-b141-d975c4021560" class="">Each thread created by a process is assigned a scheduling priority.</p><p id="217ce751-7463-4535-8844-dbadcabf8b37" class="">The operating system&#x27;s scheduler maintains a queue of threads for each priority level and assigns a time slice to each thread in turn.</p><p id="d42585f3-110a-4a10-ade7-946b1e7f9011" class="">Only the highest priority threads that are ready to run are scheduled.</p><p id="8061566b-6d85-4b0a-991f-bd0c7dccb38f" class="">If there are no threads in the highest priority class ready to run, the next lowest priority class is checked.</p><h1 id="6fb07c5d-7728-4be3-a82f-d67e04ac2bb7" class="">Simultaneous Multi-Threading</h1><p id="773a41c8-e3ca-489f-ac40-bd3c2777b9dd" class=""><em>Simultaneous Multi-Threading</em> (SMT) is a technique in which two hardware threads are on one CPU core.</p><p id="1b04e285-dc65-4f87-8f08-898c9991cf7b" class="">SMT threads share the L1 instruction and data caches.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6fdfcdce-d35b-4b92-947a-053f5bfe5315"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">SMT threads running different instruction types cooperate better than two threads across different cores running the same instructions as in the latter case, they can end up fighting over the cache and causing many cache misses.</div></figure><p id="bdb12c28-a5ed-4ea0-8eac-8b3f27104f17" class="">There should only be one CPU-intensive thread per CPU core.
Developers can assign a software thread to a specific hardware thread by setting the proper thread affinity.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e7bf48ea-9648-47e4-8067-0cc3b9aaa948"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">On Windows, the <a href="https://docs.microsoft.com/en-us/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation"><code>GetLogicalProcessorInformation</code></a> function or the <a href="https://docs.microsoft.com/en-us/cpp/intrinsics/cpuid-cpuidex"><code>CPUID</code></a> instruction can be used to return the CPU core topology.</div></figure><h1 id="b2ad0897-2016-41af-93da-575f1239ab80" class="">Synchronization</h1><p id="9dbfe3eb-5706-4b6f-8587-5c74e182e190" class="">On modern processors, reads and writes of naturally aligned native types are atomic.</p><p id="0efcebc3-577e-458d-a2c5-58d860c265a9" class="">However, there is no garantee that the compiler will use an atomic instruction for increments, or decrements.</p><p id="f52c594e-84d7-484c-a724-bcb1cb9fee6e" class="">When there is a shared resource like a global variable, the threads must make sure they share access to that resource.</p><pre id="2e5a0591-eca4-4778-9788-8d627bc8b071" class="code"><code>class Object
{
  int _counter;

public:
  void AddReference()
  {
    _counter++;
  }
};</code></pre><p id="60746c86-52cb-452e-8a54-3759a2e5c86e" class="">If two threads happen to call <code>AddReference</code> at the same time, instead of both incrementing the <code>_counter</code> variable, a <em>race condition</em> could potententially occur.</p><p id="1f1b8ed6-7a7f-4c1b-b1de-03c96f1ae349" class="">The assembly for this simple operation would look like:</p><ol id="ee47b12d-eccf-46db-9f4c-7c5cd0a24df7" class="numbered-list" start="1"><li>Load¬†<code>_counter</code> into register R.</li></ol><ol id="7db6bdc3-8a65-43c7-8fa9-58aacdf3c0ea" class="numbered-list" start="2"><li>Increment register R.</li></ol><ol id="9e311904-95d6-4a77-8a94-4ad971022e46" class="numbered-list" start="3"><li>Store register R back into¬†<code>_counter</code>.</li></ol><p id="45367ba3-3951-4951-a561-89c36c325949" class="">The increment operation is actually divided into three operations, and when a second thread try to increment the <code>_counter</code> variable, the first thread could be executing any of these three steps.</p><p id="2786848c-a880-4a56-8cf2-9e0965458158" class="">Assuming the <code>_counter</code> variable is initially set to 1.</p><p id="758b1e71-60db-4d4e-8d7a-4ca4ff341aa4" class="">If thread 1 hasn&#x27;t yet completed the third step, then thread 2 will read the same initial value in the first step. The two threads would be incrementing <code>_counter</code> to 2. After the two threads have returned from <code>AddReference</code>, the <code>_counter</code> variable would have been updated to 2 twice, instead of 3.</p><h1 id="e1577eab-6250-4192-9ae2-ab25543e60b5" class="">Synchronization Primitives</h1><p id="c4fce088-98f0-4d00-bb2b-74b59ac8c139" class="">For multiple threads to work together, they need to be synchronized in order to communicate and share resources.</p><p id="47fe3160-8eba-4dfd-8de5-6f0f0f363886" class="">Each platform provides a set of synchronization primitives.</p><ul id="389c0152-490f-4b41-8202-08474ff816da" class="bulleted-list"><li>Mutexes</li></ul><ul id="d28e5c4a-fcaf-4813-a968-d6e41b2dcdc7" class="bulleted-list"><li>Critical Sections</li></ul><ul id="0de60392-5839-4c0e-9fe4-214ae260f86c" class="bulleted-list"><li>Semaphores</li></ul><ul id="74366f38-5807-4114-8138-70c579cff184" class="bulleted-list"><li>Events</li></ul><ul id="245f9677-3e2b-483d-871f-9e6f0d4010e7" class="bulleted-list"><li>Timers</li></ul><h2 id="63846d79-287c-4985-9614-9621f701d861" class="">Mutexes</h2><p id="a425b9ae-7cb6-424f-bcb5-32f4f2795aa0" class="">Mutexes are used to protect a resource so that only one thread at a time can have access to that resource.</p><p id="1118e6aa-698d-469c-9bb9-d179491d610f" class="">A thread waits on the mutex, and, when the wait succeeds, accesses the resource.</p><p id="7e1a8735-702c-4651-8c4b-25950143bfcb" class="">During this time, all other threads that wait on the mutex will be blocked and placed in a queue to obtain ownership of the resource.</p><p id="6c44584d-72b3-43a8-90cc-0da1e1e38e90" class="">When the first thread is finished accessing the resource, it releases the mutex. The next thread (if any) waiting on the mutex is then given access.</p><h2 id="179e7363-746f-4c8c-852e-4450aba57263" class="">Critical Sections</h2><p id="7cf7bc4e-4264-46c7-b6aa-f3dc2ac3868e" class="">Critical sections are similar to mutexes except that they are slightly faster and must be accessed with their own set of synchronization functions.</p><h2 id="2a86f712-0df7-406d-820f-01f416793472" class="">Semaphores</h2><p id="dc521a9b-f9cd-4abf-a056-c7c1d779212d" class="">Semaphores are similar to mutexes in that they protect a resource, but they differ in that they allow a specified number of threads access to the resource before blocking additional threads requesting access.</p><p id="3173c64d-b49c-4a20-9bc7-622ab0d91b0d" class="">For example, if only four threads were to be given access to a resource at a time, a semaphore with a count of four would be created. As each thread waited on the semaphore, the count would be decremented. When the fifth thread waited on the semaphore, it would block until one of the other threads currently using the resource finished doing so and signaled the semaphore.</p><h2 id="38ed71ec-f610-4ee6-9b19-eb53926acc4d" class="">Events</h2><p id="c8813569-b420-4549-98c9-4846bb24377b" class="">Events are used by threads to wait for certain events to occur.</p><p id="83120cde-7f4c-405d-b4f3-df013fc6d2d0" class="">A thread waiting on an event is blocked until that event is signaled by some other thread.</p><p id="65c0bee1-9d7b-41ed-bcc9-b6cd984de672" class="">When an event is signaled, either a single thread or multiple threads waiting on that event are waked and allowed to execute.</p><h2 id="ddf8e0de-0c3a-4c63-9c76-f884905169fb" class="">Timers</h2><p id="22fa1a59-916a-4d0d-b131-d1d701a26253" class="">Timers provide an object handle that will be signaled after a specified period of time has elapsed.</p><hr id="26c35ef0-9b1c-415e-9868-2efb67481762"/><h2 id="2acddaca-676e-4dfa-a9d5-dd4b6135ef1f" class="">Examples</h2><p id="3dad6360-16d1-4042-b48f-dd561b8ade76" class="">Multiple threads can each have a handle to a mutex object that is used to control write access to a variable. Before accessing a shared resource, the threads must call one of the wait functions.</p><p id="9ee23360-f7fd-41a0-8e54-0c495a24b72f" class="">Critical sections and interlocked functions are the most lightweight and efficient synchronization primitives.</p><p id="2dc9efb1-2058-4ff3-884f-c52ff4e2c74b" class="">They provide a more efficient means of synchronization than mutexes.</p><ul id="77e0dd8c-db56-4566-8abc-6d80d43952b7" class="bulleted-list"><li>A thread can request ownership of a critical section, without blocking upon failure to obtain the critical section.</li></ul><ul id="b702052a-6d14-4f39-9e80-391cf3c3283a" class="bulleted-list"><li>Aninterlocked function can perform some operations without requiring synchronization.</li></ul><h3 id="436d27c6-85f6-45f9-a01c-c51b7f8c9c0d" class="">Locking</h3><p id="dc0ceb89-8584-4832-be2e-b67f11d45e38" class="">When a thread needs exclusive access to a resource, it calls a locking function.</p><ul id="9e2ffe50-2a62-4998-ad04-5a46002e72bb" class="bulleted-list"><li>If the object is already locked, the thread will stop running until the resource becomes available.</li></ul><ul id="6521a3af-821e-4d83-906b-855093fc5cb4" class="bulleted-list"><li>If the object isn&#x27;t already locked, the thread will acquire the lock to stop other threads from accessing the resource.</li></ul><ul id="4aecfd7f-20ce-4b10-ad22-fe52c14d9c92" class="bulleted-list"><li>When the thread is done with the resource, it releases the lock and continues.</li></ul><p id="b961e8ae-0b94-45d3-a95c-f463785ff4b1" class="">For example, using the C++11 <code>mutex</code>:</p><pre id="4758b801-1718-41c2-ae80-c5b6fd684a43" class="code"><code>#include &lt;mutex&gt;

class Object
{
  std::mutex _mutex;
  int _counter;

public:
  void AddReference()
  {
    _mutex.lock();
    _counter++;
    _mutex.unlock();
  }
};</code></pre><p id="89bf7fd2-f4ee-482f-ad20-f1d95e4d8300" class="">The <code>_mutex</code> variable is a mutex owned by the class.</p><p id="59b9fc46-7323-440d-9ad0-529b67a2e463" class="">Before incrementing the counter, the mutex is locked. The other threads will be blocked when trying to lock the mutex again.</p><p id="e9b71479-bf67-40e1-891a-b4a37eed0f91" class="">After incrementing the counter, the mutex is unlocked. Only one other thread will be able to proceed and increment the counter again.</p><h3 id="73c406bd-6496-4184-a26a-f9f2c65e2c83" class="">Atomics</h3><p id="38420f24-e312-4888-bc4d-fa31de2151f4" class="">A better alternative is to declare the counter as an <code>atomic</code> variable.</p><p id="a42f6e0a-8531-4a25-b065-d36bb89a482a" class="">For example, on Windows:</p><pre id="f629ca5d-09c7-46ca-be71-b6e03c5e1557" class="code"><code>#include &lt;atomic&gt;

class Object
{
  std::atomic&lt;int&gt; _counter;

public:
  void AddReference()
  {
    _counter++;
  }
};</code></pre><p id="f64628bc-d8c8-476d-9b5b-8e941ead66f1" class="">Another efficient implementation is to use a platform-specific interlocked functions that can perform a load/increment/store as a single operation.</p><p id="99f2ff94-e42c-48db-bbbe-cb765a61c123" class="">For example:</p><div id="92c3d7d0-11c7-4ed0-8194-39176228f3cc" class="column-list"><div id="a8a15935-e8a1-42bf-807c-3dab87f1a879" style="width:50%" class="column"><p id="8c0c325e-4a1a-495c-9214-7ac34594e2ec" class="">On Windows and Xbox:</p><pre id="7678faaa-27a9-49af-af2d-beceae289bf2" class="code"><code>#include &lt;windows.h&gt;

class Object
{
  int _counter;

public:
  void AddReference()
  {
    InterlockedIncrement(&amp;_counter);
  }
};</code></pre></div><div id="089fbac1-5c11-423a-abcf-85e125a6719b" style="width:50%" class="column"><p id="7eb1ed4f-3b70-4015-82b5-73e4c8d7146d" class="">On macOS and iOS:</p><pre id="9d02e4a6-736e-4d22-8baf-aa040cc0a2a4" class="code"><code>#include &lt;libkern/OSAtomic.h&gt;

class Object
{
  int _counter;

public:
  void AddReference()
  {
    OSIncrementAtomic(&amp;_counter);
  }
};</code></pre></div></div><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="bc277ea9-a3b1-4d02-9b4a-de41b2ed5cc1"><div style="font-size:1.5em"><span class="icon">‚ö†Ô∏è</span></div><div style="width:100%">Interlocked functions and critical section operations will take much longer if other threads are writing to the same cache line.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="1d33155d-9d6d-474f-ae48-70a6d4cd9bee"><div style="font-size:1.5em"><span class="icon">‚ö†Ô∏è</span></div><div style="width:100%">On Windows, the interlocked functions are full-memory barriers ‚Äî they effectively have a CPU memory barrier both before and after them, which means that they are a full read-acquire or write-release barrier all by themselves.
On Xbox 360, the <code>Acquire</code> and <code>Release</code> versions of the interlocked functions should be used as they come with a memory barrier.</div></figure><h2 id="115ba022-9c62-4383-a93e-bcf82e4fd030" class="">Volatile Variables and Reordering</h2><p id="5f4749cf-3984-4e8c-a692-d30dcd60e8c2" class="">In the C++ standard, the <code>volatile</code> keyword prevents the compiler from applying optimizations.</p><p id="e0b7b1f2-1406-42ad-a712-8d5aa61319a0" class="">Volatile reads and writes cannot be reordered by the compiler.</p><p id="39193189-0e9f-492f-b710-6b545e284752" class="">However, the compiler can still reorder non-volatile reads and writes relative to volatile reads and writes.</p><p id="4bff29a9-a8e2-4cfb-bb60-135c9123c921" class="">Additionally, volatile does not prevent CPU reordering.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="e5125f06-56b1-479b-ac16-4cc09f4f0e3f"><div style="font-size:1.5em"><span class="icon">‚ò†</span></div><div style="width:100%">On Windows and Xbox, the Visual Studio C++ compiler will not rearrange any reads and writes past volatile variables.
On Windows, the compiler also prevents the CPU from reordering reads and writes.
On Xbox 360, the compiler does not.</div></figure><h2 id="489273ab-4e10-49c4-b818-bce78b613d4d" class="">Deadlock</h2><p id="d7b555b7-22f4-456b-b9aa-28aa195221b6" class="">A deadlock occurs when two threads are both trying to lock two separate resources at once.</p><p id="99917d45-a775-4ce4-9ba5-c1b7b87afe9c" class="">It can occur if two threads try to acquire the same two locks but acquire them in a different order.</p><p id="090b753a-3f8f-4675-99f9-ddb3fcbbcdad" class="">For example, with two threads trying to access object A and B:</p><pre id="91013027-6319-496a-a12f-95ae483b6d4d" class="code"><code>void Thread1Func()
{
    A-&gt;Lock();
    B-&gt;Lock();

    ...

    B-&gt;Unlock();
    A-&gt;Unlock();
}

void Thread2Func()
{
    B-&gt;Lock();
    A-&gt;Lock();

    ...

    A-&gt;Unlock();
    B-&gt;Unlock();
}</code></pre><p id="b3b1b6fa-0630-44ac-82e0-c574a4b08bb9" class="">If thread 1 acquires object A and at the same time thread 2 acquires object B. Thread 1 will wait indefinitely for object B and thread 2 will wait indefinitely for object A. This is an example of deadlock.</p><h2 id="e8d42c3f-b260-4092-8872-cb34ed685eab" class="">Priority Inversion</h2><p id="fa6f0022-9f32-48ee-8ebd-23c3058a445f" class="">The scenario in which a high-priority thread spins in a loop while waiting for a low-priority thread to release a lock is called <em>priority inversion</em>.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="99fe1838-da83-4b17-b25e-bd222a5b45f3"><div style="font-size:1.5em"><span class="icon">üéÆ</span></div><div style="width:100%">On Windows and macOS, the operating system&#x27;s scheduler solves this problem by randomly boosting the priority of the low priority thread.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="dc44967b-61d0-4825-ae15-23f63457f9f6"><div style="font-size:1.5em"><span class="icon">‚ò†</span></div><div style="width:100%">On Xbox, the developer explicitly assign software threads to hardware threads, and there is a no protection against priority inversion.</div></figure><h1 id="9e6a235a-9375-4fed-a207-e93aaf3b8e4c" class="">Managing Threads</h1><p id="5b8ed3b0-d8a0-4447-ad65-aa8bc31b8abb" class="">The proper way of handling a thread is waiting for it to terminate, and then cleaning it up.</p><p id="9198da5f-a4ed-440b-816d-d516ecdd7bce" class="">Child threads do not need as much stack as their parent thread. On Xbox, their stack size should be specified as a multiple of 64-KB.</p><p id="08c53d51-e09e-4c0c-bc09-75c9597e64d8" class="">Creating and destroying threads is an expensive operation. It is recommended to use a thread pool of threads that wait around for work instead.</p><p id="22c43e0e-c893-47ef-8dd6-e5c5a3341558" class="">It is recommended to let a thread exit normally by returning from its functio. </p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="c8622122-4214-465c-aa6a-b398ad875b3a"><div style="font-size:1.5em"><span class="icon">üéÆ</span></div><div style="width:100%">On Windows and Xbox One, a thread is created with¬†<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread"><code>CreateThread</code></a>.
In C++, it is not recommended to exit a thread with <a href="http://exitthread.as"><code>ExitThread</code></a> as destructors will not be called.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="75890df0-6a91-4e0c-8796-187e07068d81"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">On Xbox 360, the software threads must be explicitly assigned to hardware threads with <code>XSetThreadProcessor</code>. Otherwise, their are created on the same hardware thread.
On Windows <code>SetThreadAffinityMask</code> can be used to suggest to the operating system which hardware threads to use, but it is not recommended as other processes are running on the system.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="bd57a910-25c9-4113-a613-fc19c312d2db"><div style="font-size:1.5em"><span class="icon">üéÆ</span></div><div style="width:100%">On Xbox 360, it is recommend to use the CRT¬†<code>_beginthreadex</code>¬†function to creating a thread to properly intialize the C runtime.
Similarly, a thread should either return normally; or be exited with <code>_endthreadex</code>.</div></figure><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a01c4641-340b-428a-abda-c9eee63f9c1a"><div style="font-size:1.5em"><span class="icon">‚ò†</span></div><div style="width:100%">Threads should never be suspended manually as it can lead to deadlocks. On Windows and Xbox, <code>SuspendThread</code> should be never be used.
Threads should also never be terminated manually as they will not be properly cleaned up. On Windows, <code>TerminateThread</code> should never be used; on Xbox it is not available.</div></figure><h1 id="e3e7ea3c-b1b9-4f4e-8dba-fa515bdb43d2" class="">Fibers</h1><p id="f320b305-ea16-4ac2-a27e-afc09781d5b0" class="">A <em>fiber</em> is a unit of execution that must be manually scheduled by a program.</p><p id="796ae983-0571-4224-905b-023bf1e73106" class="">Fibers run in the context of the threads that schedule them.</p><p id="2943b4a1-9403-4e05-812f-0b0bffb309a5" class="">Each thread can schedule multiple fibers.</p><p id="fac686fc-2174-4f3b-aca6-4c40d43e614e" class="">A fiber has its own stack and a subset of the thread&#x27;s registers.</p><p id="b929f693-86ce-429c-994b-fb23cc4c626f" class="">Fibers are not preemptively scheduled.</p><p id="602909ff-719c-4f40-a050-09a0e6c7590f" class="">A fiber can be terminated by any running fiber, including the currently executing fiber.</p><h1 id="12217c48-44f9-4e8f-a90f-c8bd779ede4d" class="">Multithreading architectures</h1><h2 id="79366c15-06ce-491d-9c4b-143e54aa9f9f" class="">Pipeline</h2><p id="77423680-8327-4c9b-af0e-9eed59aa52fa" class="">In a pipeline architecture, data structures need to be locked before being written to or read from.</p><p id="cad9b73f-d1ee-4025-9b19-708ddcb28fa1" class="">Buffers can be double-buffered or triple-buffered to minimize the amount of time spent during a locked.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d7703793-4793-4a37-b144-14358dca8d7e"><div style="font-size:1.5em"><span class="icon">üéÆ</span></div><div style="width:100%">Direct3D 9 and 11 use a pipelined architecture in which buffers need to be lock and unlocked. The runtime returns a pointer to a new region of memory instead of the old buffer data if the GPU is still using the buffer.
Direct 3D 9 ‚Äî <code>Lock</code> and <code>Unlock</code>.
Direct 3D 11 ‚Äî <code>Map</code> and <code>Unmap</code>.
In Direct3D 12, the application is responsible for pipelining data updates.</div></figure><h2 id="3187baba-8565-49a8-bf56-8e593d396489" class="">Contractor queue</h2><p id="020f5fd6-941d-4ba8-9e77-7dfb6df21f96" class="">In a contractor queue architecture, a primary thread acts as the task master and creates a queue of independant tasks. While the task master waits for the completion of the tasks, the worker threads each take a set of iterations and run over them in parallel. When the queue is empty, the threads all combine back into the master thread.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9bb448f8-eca5-4c50-99a8-8254c0846ae2"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">The compute shaders executed by the GPU use a contractor queue architecture.</div></figure><h2 id="ab4add3f-1866-4fc3-8d0a-23223c161c35" class="">Work crew</h2><p id="83778582-1ae3-4f5d-9e6a-9666b50142c9" class="">In the work crew architecture, many threads work on independent tasks that all interoperate.</p><p id="73473285-88ce-48da-8f55-4b41c523f692" class="">For example, loading threads use a work crew architecture.</p><h1 id="e1090f56-c3e9-475a-97e8-942d1b738211" class="">Synchronization Examples</h1><p id="37917c9e-9628-4180-a1ff-347e0673909b" class="">For multiple threads to work together, they need to be synchronized in order to communicate and share resources.</p><p id="dc96cd0e-cc4a-493c-b524-43af71a7e836" class="">Each platform provides a set of synchronization primitives.</p><h2 id="c2bf4b8c-ed7b-410f-937e-a66723a12a8a" class="">Exclusive Access</h2><h3 id="65b74b2f-dc7f-4f0b-a94a-2dd5a0f95870" class="">Mutex</h3><p id="89479e53-3fa0-4e2e-aaf4-b3bc4068a756" class="">A mutex can be used to gain exclusive access to a resource.</p><p id="f63eca68-f7ac-4613-ac17-86f612ffbc68" class="">The operating system guarantees that, for a particular mutex, only one thread at a time can 
acquire it.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="212065d8-38ba-4394-82b7-673f73ec5b83"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">A mutex can be used to synchronize between multiple processes.</div></figure><p id="4635a359-bb2d-4a48-8712-eabc2634bee5" class="">On Windows and Xbox:</p><ol id="11476372-efb8-4ce9-bc90-4b21f7a4c341" class="numbered-list" start="1"><li>Create a mutex<pre id="abc636a7-0d63-48a9-b350-a8f0c9e03f43" class="code"><code>HANDLE mutex = CreateMutex(0, FALSE, 0);</code></pre></li></ol><ol id="ab587ab0-89ed-4d53-8eac-a24af1895c44" class="numbered-list" start="2"><li>Manipulate shared data<pre id="f8c6000b-18f5-4d62-bff3-959beda95455" class="code"><code>WaitForSingleObject(mutex, INFINITE);
...
ReleaseMutex( mutex );</code></pre></li></ol><ol id="69d9d471-23de-43ee-9271-cd17dcd97fb4" class="numbered-list" start="3"><li>Destroy the mutex<pre id="6f49a416-c7dc-4069-955a-dc3c2999c1ae" class="code"><code>CloseHandle(mutex);</code></pre></li></ol><h3 id="e8b7658d-a167-47f8-b249-7c8eaf2f8570" class="">Critical section</h3><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6c73e9e1-3023-4fd7-adbb-5e115875b6ca"><div style="font-size:1.5em"><span class="icon">‚ö†Ô∏è</span></div><div style="width:100%">The main disadvantage to mutexes is that they are relatively expensive to acquire and release.</div></figure><p id="423aeb1c-5222-42f8-91a4-41e110784ad4" class="">A faster alternative is a critical section.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="667772a6-44cb-4bc9-9c76-ee5a2104fa5b"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">A critical section can be used to synchronize only within a process.</div></figure><p id="a305ae8f-47fe-4e2d-b858-97b6a1577ffc" class="">On Windows and Xbox:</p><ol id="3cac590f-08b8-4a20-b80c-bc6e008c9ef4" class="numbered-list" start="1"><li>Create a critical section<pre id="7fa756b3-4bbb-4557-9385-d2e986d9d681" class="code"><code>CRITICAL_SECTION cs;
InitializeCriticalSection(&amp;cs);</code></pre></li></ol><ol id="41dab0de-1e73-4e7d-af80-c435b57a8825" class="numbered-list" start="2"><li>Manipulate shared data<pre id="7013865d-2ced-4d4a-8c96-0d7b5ad2fc3e" class="code"><code>EnterCriticalSection(&amp;cs);
...
LeaveCriticalSection(&amp;cs);</code></pre></li></ol><ol id="edfb0462-f508-42f1-8649-19b17eda6a07" class="numbered-list" start="3"><li>Destroy the critical section<pre id="344bae71-e728-432d-8532-b28baa5b1096" class="code"><code>DeleteCriticalSection(&amp;cs);</code></pre></li></ol><h3 id="ab995d23-9561-4357-a60f-53b83cfbb4e4" class="">Events</h3><p id="c85f2fd4-903a-417d-9f64-18dfa9e44616" class="">Events can be use to share data accross multiple threads when implementing a double-buffering or tripple-buffering strategy.</p><p id="0a974e0d-7645-47dc-8608-06ab610af540" class="">For example, if the update thread and the render thread are taking turns using a pair of render description buffers, an event can be associated each buffer to indicate when they are done with it.</p><p id="34985602-e083-4f69-affa-62c84e1f937c" class="">On Windows and Xbox:</p><ol id="10699aa4-b12c-4bfd-94a8-a7868d1356b9" class="numbered-list" start="1"><li>Create an event with <code>CreateEvent</code>.<ol id="c95b8c83-22de-422c-8113-a8c777251ec5" class="numbered-list" start="1"><li>When a thread is done with a buffer, it can use <code>SetEvent</code> to signal it.</li></ol><ol id="4deb3db3-85a9-4000-b3a6-ba8568479cb4" class="numbered-list" start="2"><li>The thread can call <code>WaitForSingleObject</code> on the other buffer&#x27;s event.</li></ol></li></ol><ol id="974c41d0-3eaa-46ff-bfa9-6ec7034dd117" class="numbered-list" start="2"><li>During cleanup, the event is destroyed with <code>CloseHandle</code>.</li></ol><h3 id="5c7a30a0-c167-49bc-a6df-c47066d58e3a" class="">Semaphores</h3><p id="b705ee0c-27b8-4c98-adef-a9f816fefd00" class="">A semaphore is used to implement work queues to control how many threads can be running at the same time.</p><p id="a842a01b-1865-4b59-b2e4-1e1dbf56fd6b" class="">One thread adds work to a queue and whenever it adds a new item to the queue, it releases a semaphore to allows one worker thread to be released from the pool of waiting threads.</p><p id="9cfd1bb1-80fa-496c-8ccd-a08af886f247" class="">The worker threads wait for a semaphore, and when it returns they know there is a work item in the queue for them.</p><p id="fd25cc28-bb93-467b-8074-7474e73e35c1" class="">Additionally, another  synchronization technique must be used to guarantee safe access to the shared work queue.</p><p id="63f09ab5-54b5-448a-9bf4-5bf1cd2bfa1f" class="">On Windows and Xbox:</p><ol id="1934bb39-716a-4eb7-92e8-530b7821bf5e" class="numbered-list" start="1"><li>The pool create an semaphore with <code>CreateSemaphore</code>.<ol id="c973e329-26bf-4fbf-aa7b-e72b7d823a5a" class="numbered-list" start="1"><li>The worker threads call <code>WaitForSingleObject</code>.</li></ol><ol id="619d1388-fbdd-40e2-ae7c-70e608370043" class="numbered-list" start="2"><li>When a worker thread&#x27;s task is finished, release the semaphore with <code>ReleaseSemaphore</code>.</li></ol></li></ol><ol id="a3f8e34b-42f4-4073-a657-aa21c7f00bdd" class="numbered-list" start="2"><li>During cleanup, the pool waits for all threads to terminate with <code>WaitForMultipleObjects</code>.</li></ol><ol id="203d56b2-6c16-4059-93ab-e358fe609240" class="numbered-list" start="3"><li>The semaphore  is destroyed with <code>CloseHandle</code>.</li></ol><h1 id="e10a6549-54c8-4ae9-a46a-501c678de8e2" class="">Lockless Programming</h1><p id="a314f629-e839-4c3c-a7db-1de4026f2949" class=""><em>Lockless programming</em> is a way to safely share data between multiple threads without the cost of acquiring and releasing locks.</p><p id="1d43792d-b0d7-4fca-8982-dccb32025099" class="">Interlocked functions can perform simple thread-safe operations without using locks.</p><p id="369fc73b-b958-48e2-9f10-7a095c9dc709" class="">The use of these functions is called lockless programming.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="3f7e1a92-64f8-4e3c-abec-f48d3c7f5bf7"><div style="font-size:1.5em"><span class="icon">‚ö†Ô∏è</span></div><div style="width:100%">Lockless algorithms are not guaranteed to be faster than algorithms that use locks.</div></figure><h2 id="c4bca2f3-bbca-41e7-920e-d56730718cb3" class="">Lockless Containers</h2><p id="54de49e8-1cc3-4810-84b0-24dd4a8a9d0d" class=""><a href="https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/system_overview_XLockFree_sep13.aspx">https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/system_overview_XLockFree_sep13.aspx</a></p><p id="0dbc0cff-5dee-4178-be93-31a55007dcad" class="">Data can be safely shared between threads using lockless containers.</p><p id="9ec7324f-4c06-4b9a-bd86-9e72d874784e" class="">Code that executes on parallel threads can add and remove elements on the lock-free containers simultaneously.</p><ul id="8eb8aa14-a16e-40e9-aedf-9781e35365f1" class="bulleted-list"><li>Lock-free Stack</li></ul><ul id="7c5e103f-6eed-4aec-a96b-e46d897b8d49" class="bulleted-list"><li>Lock-free Queue</li></ul><ul id="9cc97e65-0079-48dd-90c4-1960fbad08ab" class="bulleted-list"><li>Lock-free Priority Queue</li></ul><ul id="048d36ea-32c2-4d7b-bdf7-9cd358c96228" class="bulleted-list"><li>Lock-free Hash Table</li></ul><h3 id="61002d61-e983-4c95-b8c8-40837fc1a81c" class="">Lock-free Stack</h3><p id="a947ead7-708f-4f6c-9708-88db88cc5143" class="">Provides a thread-safe mechanism for adding and removing data elements from a last-in-first-out (LIFO) data structure.</p><h3 id="672a8982-ad06-444d-af1f-a5acbe48ffe4" class="">Lock-free Queue</h3><p id="f4c6de07-bb03-4615-9a16-db40e85bb4a0" class="">Provides a thread-safe mechanism for adding and removing data elements from a first-in-first-out (GIFO) data structure.</p><h3 id="8dcafb7c-2776-4b6c-956c-b1779d216306" class="">Lock-free Priority Queue</h3><p id="c2a719b4-c162-4229-957d-ce886bb86500" class="">Provides a thread-safe mechanism for adding and removing data elements from a prioritized queue structure where the elements are sorted according to a key.</p><h3 id="68101bcf-1e1d-44d2-8c66-ebb6c3e76a1e" class="">Lock-free Hash Table</h3><p id="d68fe41e-5dc2-495d-84af-d18a38cf2b06" class="">Provides a thread-safe mechanism for adding and removing data elements from a hash-tree structure based on a hash key value.</p><h2 id="ca8c33f2-af23-4fe1-9d6d-41f6ac48848f" class="">Logging</h2><p id="a21cfb30-0599-4f7f-b563-c88af9c351e7" class="">The logging functions should be implemented using a thread-safe mechanism to perform physical writes to a log file on a specified hardware thread.</p><h1 id="e281e2b6-5f1b-4978-96f5-1f08695d4119" class="">Best Practices</h1><ul id="929026fc-ec22-4e38-9fc9-9d987e256ff1" class="bulleted-list"><li>Use as few threads as possible on each processor.<ul id="ad5117d5-9e1c-4f70-b048-bf84eba0ef55" class="bulleted-list"><li>Minimize context switching.</li></ul><ul id="b56fad53-2b28-49a1-8058-70fe6a446d6a" class="bulleted-list"><li>Minimize use of system resources.</li></ul></li></ul><ul id="eeb979ab-59fe-4214-b506-45d8a5bcef98" class="bulleted-list"><li>Schedule threads on all available processors.</li></ul><h2 id="366785cc-c6b6-4177-929a-0bae6063c5dd" class="">Synchronization</h2><ul id="16fc1afb-7c56-440f-be56-fc68e0a09e81" class="bulleted-list"><li>Even though some synchronization methods are faster than others, it is usually better to synchronize less often.</li></ul><ul id="6c837fe1-1c9c-4a5b-b353-dd71bcd829c0" class="bulleted-list"><li>All shared data that can be written to must be protected with a synchronization primitive.</li></ul><ul id="e8568676-5469-4035-830d-6f2edb118795" class="bulleted-list"><li>Minimize the amount of shared data.</li></ul><ul id="f25ef428-6851-42eb-bef6-97cbe63f3be2" class="bulleted-list"><li>Minimize the time spent updating shared data.</li></ul><ul id="c0a0d361-d1c2-42e8-ba55-da8fc0f5543a" class="bulleted-list"><li>Use lockless programming when appropriate.</li></ul><h2 id="fdc3b0dd-abe3-4a18-92f6-7860db1cf275" class="">Scheduling Priorities</h2><p id="c7bd3b5a-4bed-4905-a18c-19da85483fcc" class="">A typical strategy is to set background threads, particularly those that are processor intensive, to a low priority, to ensure that they can be preempted when necessary.</p><p id="9b61cca2-2d25-4a27-85b9-791fec30fb58" class="">The waiting high-priority thread then use a wait function, which let the system&#x27;s scheduler boosts the dynamic priority of the background thread.</p><h2 id="be216cdf-8884-4a8c-b646-e40b88e773e0" class="">Thread Local Storage</h2><p id="0982cc5f-23ae-43eb-a016-0f4261544eb7" class="">The thread local storage (TLS) is an important way of avoiding synchronization.</p><p id="8e26d901-19ed-40bc-b614-d45c215776ec" class="">Global variables can be defined as being per-thread. It gives each thread its own copy of it which can be referenced safely and efficiently without requiring synchronization.</p><h3 id="428dd9f7-977f-4f21-b69c-f83faf2a03d1" class="">TLS Storage</h3><ul id="ee341700-75a9-4165-9fc8-6ec03ea3ee01" class="bulleted-list"><li>On Windows and Xbox, use the <a href="https://docs.microsoft.com/en-us/windows/desktop/ProcThread/thread-local-storage">TLS API</a>.</li></ul><ul id="2d300a02-31c7-4cc8-90d6-1efb3d046946" class="bulleted-list"><li>On other platforms, use the <a href="http://pubs.opengroup.org/onlinepubs/9699919799/">POSIX pthread library</a>.</li></ul><p id="23f938d7-9006-4309-93d1-fa61b541fa25" class="">Steps:</p><div id="95bc62f0-0f22-49d3-8b50-9e0972e57555" class="column-list"><div id="1b3a71f1-d739-4acf-8957-de60c6d44ed5" style="width:50%" class="column"><ul id="33a9c2de-e263-40d7-8d87-9b08bea01086" class="bulleted-list"><li>During the program initialization, one thread allocates a TLS index/key.</li></ul></div><div id="21ff2005-c933-4e39-ae8b-300f90517c27" style="width:50%" class="column"><p id="dfd35c8f-9a10-45f6-abe3-0945beaf2c89" class="">On Windows and Xbox, use <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsalloc"><code>TlsAlloc</code></a>.</p></div></div><div id="5598258d-d26e-4863-91e0-fdc4364d5481" class="column-list"><div id="8ca04078-2ca3-480b-b2b4-78a6dabb8bab" style="width:50%" class="column"><ul id="3923c42e-42c7-41a0-bfc2-933a5038ab6d" class="bulleted-list"><li>Each thread allocates storage and associate the index/key with a pointer to its storage.</li></ul></div><div id="7fb090d5-87cd-4c94-900a-6dedadbcd09c" style="width:50%" class="column"><p id="ac534fd0-856b-4fdb-b117-1959bce5948a" class="">On Windows and Xbox, use <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlssetvalue"><code>TlsSetValue</code></a>.</p><p id="d700bcc8-e09d-4176-a809-072ccd84603e" class="">On POSIX, use <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_create.html"><code>pthread_key_create</code></a> and <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_setspecific.html"><code>pthread_setspecific</code></a>.</p></div></div><div id="a3b07523-8399-48df-a091-a6de3df50524" class="column-list"><div id="3bfa3829-4172-4ffa-8cf4-afaa46ba7a17" style="width:50%" class="column"><ul id="1c719034-9b4c-4930-8f65-8b653349f871" class="bulleted-list"><li>When a thread needs to access its storage, use the TLS index/key to retrieve the pointer.</li></ul></div><div id="a0ad9e51-f6d8-4f93-be9b-a90ccf1fc0cc" style="width:50%" class="column"><p id="4e409cb1-63cc-4e75-a214-ec90e0c32a8d" class="">On Windows and Xbox, use¬†<a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsgetvalue"><code>TlsGetValue</code></a>.</p><p id="c8338946-3c7a-4a61-abde-fd250bd0506a" class="">On POSIX, use¬†<a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_getspecific.html"><code>pthread_getspecific</code></a>.</p></div></div><div id="21b8ce11-9182-44bc-a99b-94ebcffb9485" class="column-list"><div id="c1d177f7-7850-4b9a-8c7e-079ec77f6b63" style="width:50%" class="column"><ul id="3f961d9b-4f32-4fa0-958a-f43a33b275c9" class="bulleted-list"><li>When a thread no longer needs the storage that it has associated with a TLS index/key, it must free that storage.</li></ul></div><div id="42e9dbc6-79ca-4922-af5b-7618ee89950f" style="width:50%" class="column"><p id="d8dc7692-3773-46ed-916c-b58255fc59cd" class="">On Widows and Xbox, use <a href="https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-tlsfree"><code>TlsFree</code></a>.</p><p id="cbe66b63-24a6-4727-a631-28f065dd8274" class="">On POSIX, use <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_key_delete.html"><code>pthread_key_delete</code></a>.</p></div></div><h3 id="18bfb544-7057-4a67-b696-6a1d9a17db4e" class="">TLS Variable</h3><p id="4c5117b0-9a03-4fb3-af6c-267d9a63d09a" class="">Alternatively, a TLS variable can be declared.</p><div id="1083c85f-7753-409a-8699-8cb31c64a1f3" class="column-list"><div id="0e08706b-c50c-4541-92e2-26c4b1ade12c" style="width:50%" class="column"><ul id="3e3a3d88-eba5-4e64-8acd-e6876fcd563f" class="bulleted-list"><li>MSVC ‚Äî the <code>__declspec</code> keyword and the <a href="https://docs.microsoft.com/en-us/cpp/cpp/thread"><code>thread</code></a> attribute.</li></ul></div><div id="821fe54a-7210-450c-8e80-19f90c9ae7c8" style="width:50%" class="column"><pre id="9d17a6d4-a4ac-4107-9d05-8deebb6782f6" class="code"><code>__declspec(thread) int tls = 1;</code></pre></div></div><div id="1cf021be-2286-4607-9689-ab572fa55cd8" class="column-list"><div id="05368949-b9e9-4e14-802e-98d054421765" style="width:50%" class="column"><ul id="3621b82a-606c-4e07-88ff-893284320061" class="bulleted-list"><li>Clang/GCC ‚Äî the <a href="https://gcc.gnu.org/onlinedocs/gcc-3.3/gcc/Thread-Local.html"><code>__thread</code></a> keyword.</li></ul></div><div id="c63c7abe-a49c-4cfd-b974-d826979ffb3d" style="width:50%" class="column"><pre id="9604ca7e-dbd2-42c2-ad73-7e07deb13c3e" class="code"><code>__thread int tls = 1;</code></pre></div></div><h2 id="e5973cab-d102-43a4-a589-8b851522afc9" class="">Timing</h2><p id="afd7848d-4fb0-4693-9a98-6ace86113e82" class="">The <code>rdtsc</code> instruction should not be used directly as it not necessarily synchronized between CPUs.</p><p id="a4e4d94a-5c83-4601-9739-4c0b94f6703b" class="">Use the Windows QPC API, or the C++ chrono library with a high-performance clock instead.</p><h2 id="35e1722e-9fad-47a7-9b03-bc0c100c6f37" class="">Debugging</h2><p id="23fd71b2-c2c9-468c-93da-ec8589b03341" class="">A well balanced multithreaded system will reduce long stalls where threads are waiting on each other.</p><p id="4047be3d-bc80-4a91-b299-372f41b74d23" class="">Some multithreaded bugs show up only rarely, making them difficult to find and fix.</p><h1 id="f6f659fe-b7c4-4dfa-8831-ac43cfc509d2" class="">Use Cases</h1><h2 id="a20a5c9b-fd7d-400e-a768-96ce14a66959" class="">Loading</h2><p id="c991031c-8c8a-4ccf-a4b8-0333c61e9d7c" class="">Data is typically compressed which helps reduce the size on disk but increases the worklow of the loading.</p><p id="bbb682a9-558f-4164-970e-7d2c406dfe20" class="">A file loading thread that handles decompression should use asynchronous file I/O to process load requests from the update thread.</p><p id="430c5a7a-547c-4bc8-9d72-cf8cd4051212" class="">The loading thread should perform large reads in order to maximize data-reading efficiency.</p><h2 id="f6a9c26a-d130-42e8-aedc-9702afc9e26c" class="">Rendering</h2><p id="12de5b97-20c0-4c3d-bb42-e70205a8cd28" class="">The rendering can be put on a separate thread.</p><p id="b036015f-1ee6-4e0c-8426-ef4566e2e7a0" class="">The most simple strategy is for the rendering thread to handle rendering operations so that the update thread has less workload.</p><p id="fbcebe93-be14-4727-bb29-1790ec049a69" class="">A more complex strategy is that the update thread prepares render buffers and render commands which the rendering thread can process.
The update thread is one frame ahead of the render thread, which means that it takes two frames before user actions appear on the screen.</p><p id="8ed034ce-c3c1-4d60-b607-54a2b08df686" class="">The update and rendering threads work in lockstep with each other, their communication buffers are simply double buffered. The update thread is filling one buffer while the render thread is reading from the other.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d2fcdcd8-ed21-4892-93e5-17c884714396"><div style="font-size:1.5em"><span class="icon">‚ò†</span></div><div style="width:100%">On Windows using Direct 3D, the <code>D3DCREATE_MULTITHREADED</code> flag allows rendering on one thread and resource creation on other threads, while Direct 3D handles synchronization.
It should not be used as it will affect the performance of the rendering thread.</div></figure><h2 id="a9ddb2e2-fdc4-4208-a328-12afe22b90df" class="">Physics and Animation</h2><p id="ffca5ab7-f9d7-4c2e-a164-e761a48964b7" class="">Physics and animation cannot be put onto a separate thread because the update thread requires the results of the calculations immediately.</p><p id="14df505e-103c-425f-b294-b24c24cdd5ff" class="">Instead, the calculations are handled as jobs on multiple threads.</p><p id="88631f2b-d006-4db5-ae07-d4ed0225871c" class="">Careful design of data structures and synchronization points is important.</p><h2 id="9a779f34-6a38-4c15-b93b-c7591c369dd7" class="">Optional Simulations</h2><p id="91ba0687-536c-4d24-8417-7c4c8212fd53" class="">Some simulations can be handled by the job system such as procedural geometry (clouds...), cloth, hair and fuilds simulations.</p><p id="9efb498b-6afa-4c60-9e65-e56cbb9fb7c4" class="">They typically don&#x27;t require complex synchronization with the update thread.</p><p id="7e77ef96-e15c-4676-afc1-c1a00c08d5e1" class="">They do not need to run at a fixed frame rate.</p><p id="514b2c6c-f294-4155-9d47-060a7435a6fc" class="">Their complexity can be scaled down on lower systems.</p><h1 id="90982925-70a0-438c-a3dd-cb5f2ac678d0" class="">Worker threads</h1><p id="822f81e4-e449-48fe-94e4-3e772fc0a7d9" class="">There are two designs to implement worker threads.</p><ol id="2feab81d-5221-4fae-b8f4-1db0c05c3f16" class="numbered-list" start="1"><li>Each worker thread pulls assignments from their work queue as quickly as it can in a loop.
The data goes from the update threads to the worker threads and then to the render thread, there can be a delay of three or more frames before some actions appear on the screen.</li></ol><ol id="714b9339-eabd-44d2-a693-5aeb9cf292dc" class="numbered-list" start="2"><li>Several worker threads pull assignments from the same work queue.</li></ol><h1 id="ed069d3e-0c69-4ee8-a5c7-de629398b247" class="">References</h1><ul id="381ad9f7-86bb-4334-90b1-db52d203c581" class="bulleted-list"><li>Introduction to Multithreaded Programming, <a href="https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/intro_multithread_programming_sep13.aspx">https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/intro_multithread_programming_sep13.aspx</a></li></ul><ul id="b3440f99-f77e-429d-a449-c44c85a60bde" class="bulleted-list"><li>Coding For Multiple Cores on Xbox 360 and Microsoft Windows, <a href="https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/coding_for_multiple_cores_sep13.aspx">https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/coding_for_multiple_cores_sep13.aspx</a></li></ul><ul id="17c363de-a444-4d25-85b6-2bc01683f08a" class="bulleted-list"><li>Lockless Programming Considerations for Xbox 360 and Microsoft Windows, <a href="https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/lockless_programming_sep13.aspx">https://developer.xboxlive.com/en-us/xbox/development/documentation/software/Pages/lockless_programming_sep13.aspx</a></li></ul></div></article></body></html>