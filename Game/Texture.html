<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Texture</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark-href {
	font-size: 0.75em;
	opacity: 0.5;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, KaiTi, STKaiTi, 'ÂçéÊñáÊ•∑‰Ωì', KaiTi_GB2312, 'Ê•∑‰Ωì_GB2312', serif; }
.mono { font-family: Nitti, 'Microsoft YaHei', 'ÂæÆËΩØÈõÖÈªë', monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, KaiTi, STKaiTi, 'ÂçéÊñáÊ•∑‰Ωì', KaiTi_GB2312, 'Ê•∑‰Ωì_GB2312', serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, Nitti, 'Microsoft YaHei', 'ÂæÆËΩØÈõÖÈªë', monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="29369097-2ccd-4f1a-abbc-2a9497e78c99" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">üñº</span></div><h1 class="page-title">Texture</h1><table class="properties"><tbody><tr class="property-row property-row-created_time"><th>Created</th><td><time>@Mar 07, 2019 12:37 PM</time></td></tr><tr class="property-row property-row-multi_select"><th>Tags</th><td><span class="selected-value">graphics</span></td></tr></tbody></table></header><div class="page-body"><h1 id="8f9c91ef-cdeb-4861-864f-1465d3ca1b42" class="">Image</h1><p id="0c7278f4-d960-42ef-8700-10c12876963a" class="">Textures contain image data.</p><p id="3bd2987f-2eb0-42ae-9b78-d6e168bc4461" class="">Textures are applied to surfaces (wrapped around 3D objects).</p><p id="592f022d-cf34-4f9d-ba6c-af44ce6a5d15" class="">Textures can be used for special techniques (ie displace select vertex positions).</p><p id="13dcfc80-551d-4c81-9b9c-c9ea352652ce" class="">The image data is stored in a specific pixel format.</p><p id="195aaf36-a474-4084-99b5-ec8c61951ed7" class="">The pixels are typically defined by 3 or 4 components.</p><ul id="53dae5ba-4d67-434a-96c9-daac812010f3" class="bulleted-list"><li>RGB: red, green, blue</li></ul><ul id="c12a2926-fb07-4209-8ec0-8ceb22e0bbc1" class="bulleted-list"><li>RGBA: red, green, blue and alpha.</li></ul><p id="09c3b2c2-dd53-48f3-9bb2-5b4fba4925a6" class="">Alpha typically defines the opacity of an image (no alpha is fully transparent and maximum alpha is fully opaque).</p><p id="97015005-c826-46c2-ad90-0a373102b29b" class="">Images defined without am alpha component are fully opaque.</p><p id="b00ba977-7824-4c99-a4a5-8c9457b6530e" class="">Typically, source images are stored in a 32-bit format where each component is represented using 8 bits values in the range [0, 255].</p><p id="7e052454-ea58-4842-8497-da0e93dfc3a8" class="">For HDR rendering, images can use a high precision format such as a float-point format where each component is represented using 32 bits values in the range [0, 1].</p><p id="1178104d-43dc-445c-91cb-f4ac0b4394ca" class="">Image data is typically organized i a row-major order.</p><h1 id="25b12246-aa20-44d7-8021-055efdef5a5a" class="">Texture Descriptor</h1><p id="d738dc74-bb1e-4c17-8154-f7b33839de55" class="">When a texture object is created, it needs to be configured on the graphics device.</p><p id="3782f31d-c740-49e1-b532-c0ee69d5a07a" class="">The properties include the texture‚Äôs type, size, pixel format, number of mipmap levels, sample count (for multisampling), and usage (read and/or write).</p><ul id="de4771c1-a9d6-43a0-bbe6-ee2ca865c3fa" class="bulleted-list"><li>Texture Type<ul id="520a4e5a-6d0b-49b7-a151-07074b24f6b2" class="bulleted-list"><li>The dimension and arrangement of texture image data.</li></ul><ul id="d0b58624-1562-4ba3-8ca4-db4a209fc9ad" class="bulleted-list"><li>single 1D, 2D or 3D image.</li></ul><ul id="255cb687-90c3-45b3-abeb-06b9f3feab3d" class="bulleted-list"><li>multiple images arranged into an array or a cube.</li></ul></li></ul><ul id="73ec47a3-e23c-4594-ba6d-6a23ce686d49" class="bulleted-list"><li>Pixel Format<ul id="9d3f9561-f6cb-4782-bc87-5a826e68b8d2" class="bulleted-list"><li>The size and bit layout of all pixels in the texture.</li></ul></li></ul><ul id="7ce473b2-26ef-4046-b84a-bc72c9f75a43" class="bulleted-list"><li>Size<ul id="f69c3eb6-b6dc-4e22-9f80-31f43bc19608" class="bulleted-list"><li>Depending on the texture type: width, height and depth.</li></ul></li></ul><h1 id="ba008958-c8b3-4dce-bb63-109b21174245" class="">Pixel Format</h1><p id="fac8dbd1-ec34-4ef6-b4c0-0905be79de68" class="">A pixel format is the organization and characteristics of individual pixels in a texture (texels).</p><p id="fc3eebd7-b5b8-4547-a49a-2384573f5bfa" class="">Graphic devices requires textures to be formatted with a specific pixel format.</p><p id="6d8b1cc5-f3c8-4657-ba57-9f55d89eaaa0" class="">The available pixel format varies on different platforms, so the source image data is typically converted offline into one of the supported pixel format on the target platform.</p><p id="d6068e0b-8956-4871-ac81-9b8d49b1baa8" class="">There are three varieties of pixel formats: ordinary, packed, and compressed.</p><p id="a46e85e9-2dcc-4cec-920c-4cb867b327d6" class="">A pixel format specifies:</p><ul id="00346df1-871f-4061-b111-252a16ee8966" class="bulleted-list"><li>The order of components (such as R, RG, RGB, RGBA, BGRA).</li></ul><ul id="45457ecd-4add-47b2-8d79-fcb3e8180a85" class="bulleted-list"><li>The data type for the component (such as float, signed int, unsigned int, normalized integer).</li></ul><ul id="beee9a95-7706-4520-8f36-45aa31ee25f2" class="bulleted-list"><li> Whether gamma compression and decompression is applied (srgb).</li></ul><ul id="1927a8ff-6b26-47fa-a2fb-2ec088c3484f" class="bulleted-list"><li>For compressed formats, the compression method (such as ASTC, BC, EAC, ETC2, PVRTC).</li></ul><figure id="03e6f32b-9dc4-4792-9b11-301260c4009c" class="image"><a href="Texture/untitled"><img style="width:1244px" src="Texture/untitled"/></a><figcaption>BGRA 32 (8 bits per components in blue, green, red, and alpha order)</figcaption></figure><h1 id="ae64dffb-9e94-4cf0-87cf-4167e4565971" class="">Data Types</h1><ul id="3159a5f1-4638-4a11-94c0-2b06a6e05a0e" class="bulleted-list"><li>float</li></ul><ul id="3bd2a85f-aa86-4425-9321-b81084fe821e" class="bulleted-list"><li>signed int (sint)</li></ul><ul id="bc269a12-c1ca-4549-85b7-ea28a92cf850" class="bulleted-list"><li>unsigned int (uint)</li></ul><ul id="e84b3c85-625c-4773-a174-309a940ed041" class="bulleted-list"><li>signed normal integer (snorm)<ul id="5d914db9-e31e-4063-820c-fc21a9d12d95" class="bulleted-list"><li>Component values are in the range [-1.0, 1.0].</li></ul></li></ul><ul id="64519dac-79bf-4f20-b4c9-d98b9f3571df" class="bulleted-list"><li>unsigned normalized integer (unorm)<ul id="6ec41aa9-71c2-4373-bf16-07c170e2d924" class="bulleted-list"><li>Component values are in the range [0.0, 1.0].</li></ul></li></ul><h1 id="4c0d654e-08c7-4a83-9909-69f2ea2ca896" class="">Texture Coordinates</h1><p id="14f85c5c-0d4d-4f46-8e7d-ddffd5e8a979" class="">In a shader, the main task of the fragment function is to process incoming fragment data and calculate a color value for the final pixels. Therefore, the fragment function must be able to read each texel and output its color (sampling).</p><p id="2be4982f-62b3-4623-86fd-a6921dccecc6" class="">The relationship between a texture and geometric surface is defined by texture coordinates.</p><p id="bd324da6-3694-4ab9-af26-c3c53eb7f608" class="">Texture coordinates are floating-point positions that map locations on a texture image to locations on a geometric surface.</p><p id="56c4097a-c45f-42a9-b22c-3becfaefdb4c" class="">
</p><figure id="8463d6a3-5c12-4e1e-9b78-05e810e11383" class="image"><a href="Texture/untitled 1"><img style="width:736px" src="Texture/untitled 1"/></a><figcaption>Texture coordinates are values from 0.0 to 1.0 in both x and y directions</figcaption></figure><h2 id="29f6d5b6-82b2-43dd-9812-e8bcafce1629" class="">Filtering</h2><p id="3c4b8ce5-5000-455f-812a-dd1f9401d3f8" class="">When the area being rendered to isn‚Äôt the same size as the texture, the sampler can use different algorithms to determine the color to sample.</p><p id="341f8922-96f2-4ec0-8568-6c63252a9048" class="">These algorithms are called filtering modes.</p><ul id="ff45d43d-8913-49fb-9391-51f1adc40e62" class="bulleted-list"><li>Magnification filter<ul id="1b180b51-70d0-4b81-8f54-f9f8c060be80" class="bulleted-list"><li>The sample is smaller than a pixel.</li></ul></li></ul><ul id="dabbb644-3ac5-4bad-9583-ab7842b7062a" class="bulleted-list"><li>Minification filter<ul id="3cda439b-ad67-4ae9-9204-f86ffe5206da" class="bulleted-list"><li>The sample is larger than a pixel.</li></ul></li></ul><ul id="f9fa1c5c-d3f3-4faa-b2d4-2999d835dd40" class="bulleted-list"><li>Mip filter<ul id="e20e3b92-1770-4586-a186-000363d13c73" class="bulleted-list"><li>To combine pixels between two mipmap levels.</li></ul></li></ul><p id="a37e85ef-3b20-4399-a7b4-b55dacc92d05" class="">The minification and magnification filters can be set to either:</p><ul id="7d38bf54-0070-47d9-92fa-bbc83f04c5cd" class="bulleted-list"><li>Nearest<ul id="da950290-68ea-4da1-814f-ea24a94e0855" class="bulleted-list"><li> Selects the closest texel to represent the sampled point.</li></ul></li></ul><ul id="b7c72781-f356-476b-ab75-06be528ccd30" class="bulleted-list"><li>Linear<ul id="bbb338c3-75de-4196-951a-56bcba8f6ccc" class="bulleted-list"><li>Selects four adjacent texels and produces a weighted average of them.</li></ul></li></ul><h1 id="16985034-2a6f-4539-b387-df120e24d447" class="">Aliasing</h1><p id="0dcf29cf-eb4c-4b41-b095-00308f0ed1e4" class="">Antialiasing is a technique that reduce the appearance of stair-step pixels when drawing any line that is not exactly horizontal or vertical.</p><p id="74b8dd44-d4de-4d49-bcdf-56c836bc4686" class="">This artifact is most noticable on the boundaries between polygons.</p><p id="3c17dabf-ef34-49c8-b314-a9799cdd46bb" class="">Antialiasing blends the pixels at the boundaries to produce a more natural look to the scene.</p><p id="7f6bdfc8-a597-4d25-a7c7-37b4d353f4e5" class="">There are two antialiasing techniques: edge antialiasing and surface antialiasing.</p><h2 id="a2260395-fb54-4e3d-925c-2c6062cd1fd3" class="">Edge Antialiasing</h2><p id="a93114e6-f76a-41cb-a026-e239f69fe2ed" class="">Edge antialiasing works by adding an alpha edge to each polygon.</p><figure id="aecfaac3-d6e7-4d2c-b0d6-f2b25cbdc852" class="image"><a href="Texture/Untitled.png"><img style="width:320px" src="Texture/Untitled.png"/></a></figure><p id="6a7f0ea6-14b3-4a8f-a3f3-636a7ec2b123" class="">The polygon edge is black and the grey fragments are partially covered by the polygon edge.</p><p id="76ea12c1-c807-46f9-bac1-8cb3878f0101" class="">The grey fragments are drawn with alpha blending and distinct levels of alpha transparency, as determined by how much of the polygon edge covered the fragment.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d8b7ea5f-2535-46e0-9bd6-f6e0f81231de"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">A larger back buffer is not needed to get antialiasing.</div></figure><hr id="33e81dff-e583-4d22-90d0-fb30591f963d"/><p id="f4e18322-dbab-423f-a138-579125885399" class="">Surface antialiasing is accomplished using either multisampling or supersampling.</p><h2 id="1b4752f5-23c2-40a7-8017-beeb4db12a38" class="">Multisampling and Supersampling</h2><p id="89958afc-7a9e-41e9-b292-0466aa611472" class="">Multisampling and supersampling require increasing the size of the back buffer, and scaling it back down using one of the multisample or supersample filters when it is copied to the front buffer.</p><p id="9fe9391e-596a-4e91-9429-b818037c0464" class="">A sample region consists of either two, four, or nine fragments in the frame buffer.</p><p id="1ec9bdf8-8cd9-47c1-9761-292ba13f5a16" class="">The z-value is computed separately for each fragment.</p><h3 id="9550fe4e-7ace-4647-9cfc-8e1924ca29a5" class="">Multisampling</h3><p id="e515cc53-f5d6-4a58-874c-511232acfc9f" class="">During polygon rasterization, the pixel shader inputs are computed once per sampling region.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="a70ae0e7-a367-4033-a683-78f04df80196"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">Multisampling can increase the fill rate since only one fragment per region is sent to the pixel shader.</div></figure><h3 id="e6a98d25-40cd-4713-a0e4-b82b35d31fea" class="">Supersampling</h3><p id="b8ac2902-1358-4f17-be5b-5c478ebbeca7" class="">During polygon rasterization, the pixel shader inputs are computed once per fragment.</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="d172e643-0405-4f89-85d9-e2724a96f790"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">Supersampling can result in crisper looking pictures, but may decrease the fill rate.</div></figure><h2 id="f8a135e6-18b3-473a-9d8e-c49342f28763" class="">Antialiasing Filters</h2><p id="d61bb1ae-bb2b-4503-99d5-159123dafe95" class="">There are three basic types of antialiasing filters:</p><ul id="994894e1-a684-49b2-8bbd-6b1664af685b" class="bulleted-list"><li>Linear</li></ul><ul id="2c2239fe-232d-4463-b83a-c4c4830aeb3b" class="bulleted-list"><li>Gaussian</li></ul><ul id="be7a46ce-1117-4620-94ba-14603d434780" class="bulleted-list"><li>Quincunx</li></ul><p id="45e24ec1-e25b-43fd-870f-09d863fc5bef" class="">The scan lines look like:</p><figure id="2309ebbd-9fc1-4568-969e-b7c15de871cb" class="image"><a href="Texture/Untitled 1.png"><img style="width:212px" src="Texture/Untitled 1.png"/></a><figcaption>Each box represents a pixel</figcaption></figure><h3 id="24b4962c-a6ee-49ce-8c66-bbedab899ba7" class="">Horizontal and Vertical Linear</h3><p id="17c6db8e-e65a-4297-963b-45e13048ddc6" class="">The two linear filters are fairly straightforward.</p><div id="f81cd85a-8617-492a-996b-e89cee76b058" class="column-list"><div id="b0b4cdd8-365b-4fa7-8a87-143ecbe70f4b" style="width:50%" class="column"><figure id="4b555733-b945-41f0-82b5-486fb9aa3397" class="image"><a href="Texture/Untitled 2.png"><img style="width:204px" src="Texture/Untitled 2.png"/></a><figcaption>Horizontal Linear Filter</figcaption></figure></div><div id="236f4b4e-7fa5-4caa-9d8e-4e6b481d3858" style="width:50%" class="column"><figure id="0b514922-31aa-4e24-9d60-6e959dbe5925" class="image"><a href="Texture/Untitled 3.png"><img style="width:201px" src="Texture/Untitled 3.png"/></a><figcaption>Vertical Linear Filter</figcaption></figure></div></div><pre id="e4c09004-5327-4f46-8622-dcb6a4b35221" class="code"><code>result = (a + b) / 2</code></pre><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="27cc27d7-26cb-4cdf-8292-3e7e7f42d446"><div style="font-size:1.5em"><span class="icon">üí°</span></div><div style="width:100%">In 2X mode, the linear filters double the resolution along one axis of the screen.
In 4X mode, the linear filters double the resolution along each axis of the screen.</div></figure><h3 id="8c2df04b-667d-4064-a8ca-f11f4bed4601" class="">Gaussian</h3><p id="c04c2294-72fe-408c-aa09-e4ef02b20e99" class="">The Gaussian filter works on nine pixels.</p><figure id="5aae9e8d-caa8-45c7-ab7a-46d4148f4758" class="image"><a href="Texture/Untitled 4.png"><img style="width:208px" src="Texture/Untitled 4.png"/></a><figcaption>The filter is applied at pixel e</figcaption></figure><pre id="fb706f3c-df47-4b7d-aa24-e8c96dcdfc30" class="code"><code>result = (a + 2√ób + c + 2√ód + 4√óe + 2√óf + g + 2√óh + i) / 16</code></pre><h3 id="4ae24667-ae73-4e29-ad84-65fea442ebe3" class="">Quincunx</h3><figure id="1cf5d01b-c897-4735-93b8-dd7728c2af72" class="image"><a href="Texture/Untitled 5.png"><img style="width:300px" src="Texture/Untitled 5.png"/></a><figcaption>The filter is applied at pixel c</figcaption></figure><pre id="86854117-4d43-49a6-8836-647ce18e7c8e" class="code"><code>result = (a + b + 4√óc + d + e) / 8</code></pre><h1 id="53e31370-31e7-4020-8a1d-290a77676728" class="">Mip Maps</h1><p id="034bfb4f-8787-480b-8f7b-e5462697206e" class="">When filtering a texture, the effect of under-sampling produces a shimmering artifact (aliasing).</p><p id="a7e0c6e1-b976-4c91-a3a2-c1a8424da32e" class="">Mipmapping is a technique devised to solve this problem.</p><blockquote id="c9f87066-c522-4a46-94b7-87d357f47b99" class="">The term mip is based on the Latin phrase <em>multum in parvo</em>, meaning &quot;much in a small space&quot;.</blockquote><p id="87974769-0126-4efc-b76f-ee10cb3e809e" class="">Mipmaps are a sequence of prefiltered textures (levels).</p><p id="1b7f7d31-45af-48d0-abd6-d285d30c7e4f" class="">Each mipmap is a factor of two smaller than its predecessor.</p><p id="9830245d-91db-4f3e-b8ad-cec845eb08f5" class="">The combination of minification, magnification and mip filters produces different results.</p><h3 id="591eca1d-ea6c-45b5-97e9-ab4079c41e77" class="">Generation</h3><p id="e0f8ef40-2217-44d1-a481-d6d3d0db77bd" class="">The creation of mipmaps involves creating smaller and smaller versions of the original texture, until a level has a dimension that is only one pixel in size.</p><p id="47d7ab9d-41d1-4c38-a3fe-565dc42436c3" class="">The number of mipmap levels is determined by the formula:</p><blockquote id="8bbcf8f2-51a0-425b-a498-5d0b1b0ad7d9" class="">floor(log2(max(width, height)) + 1</blockquote><p id="377033aa-1d0e-4f22-ab97-1b5fcc194198" class="">For example, a 512√ó256 texture has 10 levels.</p><h1 id="05624aad-58f4-4069-8a3d-1537f2cad6d8" class="">Addressing</h1><p id="87c378fd-f5cc-42b3-97ec-1c4df30dfc51" class="">Typically, texture coordinates are in the range [0, 1]. In cases where the texture coordinates are out of this range, the addressing mode of the sampler determines which color will be sampled.</p><div id="ad42eddd-137b-4ce2-8d97-9cd59319596f" class="column-list"><div id="665a057d-fd23-4c1e-96b4-110c45370d86" style="width:25%" class="column"><figure id="699c41c1-6764-4333-9c85-1f0712e13691" class="image"><a href="Texture/untitled 2"><img style="width:512px" src="Texture/untitled 2"/></a><figcaption>Clamp to edge</figcaption></figure></div><div id="a4371100-6ffa-4ec2-9019-ab2e83307b38" style="width:25%" class="column"><figure id="1478e58a-e28f-4040-ba80-226561e48655" class="image"><a href="Texture/untitled 3"><img style="width:512px" src="Texture/untitled 3"/></a><figcaption>Clamp to zero</figcaption></figure><p id="73e19c96-e435-4bd4-aeea-cecfce1014b9" class="">
</p></div><div id="ca33695a-db47-4859-9674-ce64a99a6a3b" style="width:25%" class="column"><figure id="c7b43c72-fed1-4cf4-b66d-97333122323e" class="image"><a href="Texture/untitled 4"><img style="width:512px" src="Texture/untitled 4"/></a><figcaption>Repeat</figcaption></figure></div><div id="d6121ef9-325b-46c4-a53c-834b02d9f372" style="width:25%" class="column"><figure id="ab0147ac-5007-4df3-9c2f-488706a9ace9" class="image"><a href="Texture/untitled 5"><img style="width:512px" src="Texture/untitled 5"/></a><figcaption>Mirror repeat</figcaption></figure></div></div><h1 id="02d284c4-b697-4c74-8151-ca664579f543" class="">Cube Textures</h1><p id="07002f93-3439-4dad-ad32-28f975dca739" class="">Cube textures (or cube maps) are a special type of 3D texture.</p><p id="62e78e26-5408-41e7-b8f3-aaa91e8a1a05" class="">Cube textures are a collection of six 2D textures that correspond to a direction along one of the axes of the 3D coordinate system.</p><p id="1c343892-5fc4-4f3a-b636-a381a8558a57" class="">Cube textures are typically unwrapped as a cross shape.</p><h2 id="ae311462-d67e-4e3a-ac55-0fee52c2989f" class="">Sampling</h2><p id="f9ea7d29-2a79-4302-802f-7b0200670460" class="">Cube textures are sampled using three coordinates representing a direction.</p><p id="4c12a67b-8e06-44a6-8661-db4ccc0401ac" class="">The three coordinates are treated as a ray originating at the center of the cube, intersecting the face at a particular point on the cube. </p><h1 id="fb9c590a-ee34-425e-8af7-0dc1fbe71934" class="">Compression</h1><p id="e55f49ea-4b67-4c72-91f2-3427d05029d5" class="">There are loss-less and lossy compression formats.</p><p id="b38d37a6-2ed5-42db-bf1d-39a8aea0a63f" class="">A loss-less format preserves the image contents.</p><p id="cd16c86f-8528-4ee0-9a17-530603a6f333" class="">A lossy format trades a reduction in image quality for smaller memory usage.</p><h2 id="1b129a48-e6c2-4841-b572-1eb2b85c7e57" class="">S3TC</h2><blockquote id="05e6710f-0ef6-42b7-9b82-c36e25a4ab84" class="">S3 Texture Compression (S3TC)</blockquote><p id="bd4c8157-f001-4e87-92de-083ab29e0bb3" class=""><a href="https://en.wikipedia.org/wiki/S3_Texture_Compression">https://en.wikipedia.org/wiki/S3_Texture_Compression</a></p><p id="24e1ee2b-6ff7-43aa-92b5-1926a4fecdfc" class="">Also known as DXT.</p><p id="b412f223-fafd-4c14-bf53-127673fa86c3" class="">Developed by S3 Graphics.</p><ul id="86ec4ae5-f70c-4173-b0d5-923f93c2acbf" class="bulleted-list"><li>Supported by DirectX 6.0 in 1998.</li></ul><ul id="ee3c7f88-d483-4b98-80ee-7ec418c8c954" class="bulleted-list"><li>Supported by OpenGL 1.3 in 2001.</li></ul><ul id="0e3b2874-2a2b-40e9-9aa2-bc479ba38259" class="bulleted-list"><li>Not supported on mobile hardware.</li></ul><p id="f5832225-58c6-446d-a631-a9613c2e59a8" class="">Block-based texture format.</p><p id="c1ab8ba2-366e-4eb8-897f-7f689f26b66b" class="">Codecs:</p><ul id="7683ea23-b7c9-4516-b127-98207fdcdb81" class="bulleted-list"><li>DXT1</li></ul><ul id="bc82ebf6-3e77-4782-b7ca-74196610283e" class="bulleted-list"><li>DXT2/3</li></ul><ul id="f8795e89-9f29-49c1-bb3e-b6a8c9ba38bd" class="bulleted-list"><li>DXT4/5</li></ul><ul id="d28eab19-df82-45fa-b549-ea244d310389" class="bulleted-list"><li>DXTn</li></ul><h3 id="343cfb1a-7723-4263-b358-cdcbc59ad922" class="">DXT1</h3><p id="796a8e27-593b-4433-aea2-da228f2eceda" class="">DXT1 is for textures that are opaque or have a single transparent color.</p><p id="fefb7664-9b22-4153-8f4f-99efd03e4efc" class="">Converts 16 texels into 64-bit blocks, consisting of two 16-bit RGB 5:6:5 color values (or 1-bit alpha block) and a 4x4 bitmap as a 2-bit lookup table.</p><h3 id="44fc282a-9f2a-4819-9936-a9707d7ce016" class="">DXT2 and DXT3</h3><p id="46792db9-9950-47ce-8abc-43e06e64be41" class="">DXT2 and DXT3 are for textures where the alpha channel is explicit.</p><p id="e3d6faf0-972b-453e-96d3-7b886f26d832" class="">DXT2 textures have a premultiplied alpha channel.</p><p id="e7a6eca1-5837-4826-9e4a-8b33c8adf04a" class="">Converts 16 texels into 128-bit blocks, consisting of 64 bits of alpha channel data (4-bits for each pixel) followed by 64 bits of color data (DXT1).</p><h3 id="3d669f7a-d823-43fb-8119-0cb0175163f2" class="">DXT4 and DXT5</h3><p id="ac78e222-8d15-4c10-b492-549df5c05a39" class="">DXT4 and DXT5 are for textures where the alpha channel is interpolated.</p><p id="4495f14c-0493-4e0a-ac66-fd0ba02109b5" class="">DXT4 textures have a premultiplied alpha channel.</p><p id="c11385f8-5360-4ccf-a9ce-7bfc8d3b18ad" class="">Converts 16 texels into 128-bit blocks, consisting of 64 bits of alpha channel data (two 8-bit alpha values and a 4x4 bitmap as a 3-bit lookup table) followed by 64 bits of color data (DXT1).</p><h3 id="16668001-dadc-4b02-91a1-3b300b9a5b3e" class="">DXTn</h3><p id="a5ebf33a-2571-4014-ac81-7645e0c75927" class="">DXTn supports 3D compressed textures.</p><p id="549e9bc9-cfac-4661-90f1-d7628055de00" class="">The texture is divided up into blocks that are only affected by depth and not width or height.</p><p id="2b7083e5-77d2-46e0-b205-62ccdaf11151" class="">They are one of the following four sizes:</p><ul id="2c0fc6a4-59e6-48e3-b0e9-0cc79c2a149c" class="bulleted-list"><li>4 x 4 x 1 (depth is 1)</li></ul><ul id="249b4db9-a6ab-434d-b0f3-cd7a1b830e25" class="bulleted-list"><li>4 x 4 x 2 (depth is 2)</li></ul><ul id="251f69c8-7bbc-4a26-9fc0-7a3c81a27ac0" class="bulleted-list"><li>4 x 4 x 3 (depth is 3)</li></ul><ul id="be1ea1bc-b6b5-45c9-ab7f-4715aabab261" class="bulleted-list"><li>4 x 4 x 4 (depth is 4 or higher)</li></ul><h2 id="ed184ca2-bc1c-4685-aa7e-b35a91eca6f5" class="">PVRTC</h2><blockquote id="fb8bbc58-b8a9-48f2-bd33-aca4b814e552" class="">PowerVR Texture Compression (PVRTC)</blockquote><p id="22e7966e-c27c-4eeb-aff1-572fd8f6a0d0" class=""><a href="https://en.wikipedia.org/wiki/PVRTC">https://en.wikipedia.org/wiki/PVRTC</a></p><p id="ea5b7ae6-b351-4c16-88a5-305e8078d215" class="">Developed by Imagination Technologies in 2003.</p><p id="a578b2fc-288b-496d-81ae-c0af0c59b251" class="">Operates by downsampling the source image into two smaller images, which are upscaled and blended to reconstruct an approximation of the original.</p><p id="d871856d-14e2-4281-88cd-ca3ca72e30ff" class="">PVRTC is the preferred format when targeting A7 processors.</p><h2 id="2803aad8-eb39-4779-ac8e-573de5a201f4" class="">ETC</h2><blockquote id="e4b02b3d-79d1-4a66-b776-d947c74f0d9e" class="">Ericsson Texture Compression (ETC)</blockquote><p id="3e726e96-19d0-4275-b100-8942791f3f9c" class=""><a href="https://en.wikipedia.org/wiki/Ericsson_Texture_Compression">https://en.wikipedia.org/wiki/Ericsson_Texture_Compression</a></p><p id="5615a5c6-c8eb-4e3c-a7ba-20defa65160d" class="">Developed by Ericsson in 2005.</p><p id="3326dcb2-beed-4b88-9bc6-63b3f71d28ce" class="">Block-based texture format.</p><p id="0fd08d6e-5225-48dc-9d20-92ad0dbcab5c" class="">Codecs:</p><ul id="3409427e-caab-46d0-82b8-795319d14d41" class="bulleted-list"><li>ETC1<ul id="3646be06-3e08-4abd-b2a4-d9723dd1d98c" class="bulleted-list"><li>Does not support alpha components.</li></ul></li></ul><ul id="d97518e9-7da5-473f-9ebb-844d895ec568" class="bulleted-list"><li>ETC2<ul id="a6ea2d7f-6f45-491b-aa9b-ef9b425b15c3" class="bulleted-list"><li>Expands ETC1 to provide higher quality compression.</li></ul><ul id="94ddf8ef-8ce2-4407-860e-bf984af85559" class="bulleted-list"><li>Supports alpha components.</li></ul></li></ul><ul id="a426e6fa-de9c-4a2d-ab89-9ec68d20c0ac" class="bulleted-list"><li>EAC<ul id="d87b221e-0286-4a01-a378-eb0c4c3356f3" class="bulleted-list"><li>Based on ETC1 and ETC2.</li></ul><ul id="40724b1b-947f-40fd-b0c6-4f276f8e1c5b" class="bulleted-list"><li>Used for one or two channel data.</li></ul></li></ul><h2 id="7237ad78-144e-4ee3-afac-e2c3305170f2" class="">ASTC</h2><blockquote id="a2076766-f636-4415-8865-5821d0316e9c" class="">Advanced Scalable Texture Compression (ASTC)</blockquote><p id="cafd8e57-db74-416b-b0dd-4afbb24a3760" class=""><a href="https://en.wikipedia.org/wiki/Adaptive_Scalable_Texture_Compression">https://en.wikipedia.org/wiki/Adaptive_Scalable_Texture_Compression</a></p><p id="8e84bfaa-d012-4185-941a-ec70c960d95b" class="">Developed by AMD in 2012.</p><p id="1eae2023-426d-48c1-884f-624be0d74b13" class="">Block-based texture format.</p><p id="2a12050a-1bd1-4ae2-8c5a-383a5915f5fc" class="">Incorporates a selectable block size.</p><p id="c0383ad9-e8b3-4c14-8528-827cc5b7a145" class="">ASTC offers the best quality-to-size ratio on hardware where it is available.</p><h1 id="2bff76cd-66dd-4328-bd64-a1138ceac8f4" class="">Formats</h1><h2 id="e908a64c-c118-4da9-9099-26909b1e1111" class="">PVR</h2><p id="72467ba6-e6d0-46f1-8717-c54eafff669f" class="">A PVR file can contain uncompressed data or compressed data in several formats including S3TC, ETC, and PVRTC.</p><p id="7faabf89-c32a-4d7a-822d-62d73d1dc795" class="">PVR2</p><pre id="27b691b1-8ab1-4fd5-a627-f681c0476b70" class="code"><code>struct PVR_Texture_Header
{
	PVRTuint32 dwHeaderSize;
	PVRTuint32 dwHeight;
	PVRTuint32 dwWidth;
	PVRTuint32 dwMipMapCount;
	PVRTuint32 dwpfFlags;
	PVRTuint32 dwTextureDataSize;
	PVRTuint32 dwBitCount;
	PVRTuint32 dwRBitMask;
	PVRTuint32 dwGBitMask;
	PVRTuint32 dwBBitMask;
	PVRTuint32 dwAlphaBitMask;
	PVRTuint32 dwPVR;
	PVRTuint32 dwNumSurfs;
};</code></pre><p id="35d342e5-cc4d-495d-9f20-d4558fa39e5d" class="">PVR3</p><pre id="c4723022-3845-44d9-a0b3-5664178e34dd" class="code"><code>struct PVRTextureHeaderV3
{
	PVRTuint32	u32Version;
	PVRTuint32	u32Flags;
	PVRTuint64	u64PixelFormat;
	PVRTuint32	u32ColourSpace;
	PVRTuint32	u32ChannelType;
	PVRTuint32	u32Height;
	PVRTuint32	u32Width;
	PVRTuint32	u32Depth;
	PVRTuint32	u32NumSurfaces;
	PVRTuint32	u32NumFaces;
	PVRTuint32	u32MIPMapCount;
	PVRTuint32	u32MetaDataSize;
};</code></pre><h3 id="e2731e45-e286-459d-8525-8aaa7c49af0d" class="">ASTC</h3><pre id="01a8eff6-3145-4ea6-81ee-d3782e9b2ea6" class="code"><code>#define MAGIC_FILE_CONSTANT 0x5CA1AB13

struct astc_header
{
	uint8_t magic[4];
	uint8_t blockdim_x;
	uint8_t blockdim_y;
	uint8_t blockdim_z;
	uint8_t xsize[3];
	uint8_t ysize[3];
	uint8_t zsize[3];
};</code></pre><h1 id="feec626b-ea83-4fbc-90dd-38c2df6a9777" class="">Texture Filtering</h1><h2 id="48d643d3-6518-4009-86c0-447478faa7df" class="">Anisotropic Texture Filtering</h2><p id="cb2885ec-de3e-4c10-828e-1bf2f5e59997" class=""><em>Anisotropy</em> is the distortion visible in the texels of a 3D object whose surface is oriented at an angle with respect to the plane of the screen.</p><p id="0d629e2d-cad5-4b1a-83aa-22689ed9cfd3" class="">When a pixel from an anisotropic primitive is mapped to texels, its shape is distorted.</p><p id="630955a6-7fbc-4e99-b12b-a8d1eb1e2393" class="">The anisotropy of a pixel is the elongation (length divided by width) of a screen pixel that is inverse-mapped into texture space.</p></div></article></body></html>