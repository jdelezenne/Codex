<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Shader</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark-href {
	font-size: 0.75em;
	opacity: 0.5;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, KaiTi, STKaiTi, 'ÂçéÊñáÊ•∑‰Ωì', KaiTi_GB2312, 'Ê•∑‰Ωì_GB2312', serif; }
.mono { font-family: Nitti, 'Microsoft YaHei', 'ÂæÆËΩØÈõÖÈªë', monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, KaiTi, STKaiTi, 'ÂçéÊñáÊ•∑‰Ωì', KaiTi_GB2312, 'Ê•∑‰Ωì_GB2312', serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, Nitti, 'Microsoft YaHei', 'ÂæÆËΩØÈõÖÈªë', monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="b2e5971e-120b-4e11-83ba-bf5896d0b6df" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">üé®</span></div><h1 class="page-title">Shader</h1><table class="properties"><tbody><tr class="property-row property-row-multi_select"><th>Tags</th><td><span class="selected-value">graphics</span></td></tr></tbody></table></header><div class="page-body"><h1 id="2444f278-0d88-4545-a4f7-86ce58ec2c11" class="">Overview</h1><p id="14e103a8-dda1-4fac-af21-095c5d621707" class="">Shaders are small executable programs executed by the GPU.</p><p id="ab9a51e0-afa8-4d3b-8d90-df0d468ecde4" class="">A shader program a written using a shading language specific to a graphic device.</p><p id="f2f8718b-c59a-4296-81ae-59f6e5d11683" class="">Shader programs in a graphics pipeline are responsible for all transform, lighting, and shading effects.</p><p id="b459c073-64e8-454d-b88d-76efc507ffb1" class="">Compute programs are responsible for high-performance general purpose programs using the GPU (GPGPU).</p><p id="fb5adfde-44aa-488a-90f5-f0152b37202c" class="">There are different kind of shader programs, executed at different stages of the graphic pipeline.</p><p id="a5a7c8bd-ed67-436c-bac9-0d260da95e70" class="">A GPU has unified shader architecture, which means that shader programs share the same instruction set architecture (ISA).</p><p id="31b1ece8-4f46-4fcb-ad20-4c4c383a5bb9" class="">Thanks to this architecture, a GPU can balance its workload by allocating its shader cores to different shader programs.</p><h1 id="d11b0879-4464-46db-b069-e655daffadea" class="">Shader Languages</h1><h2 id="6455c59e-1f4f-41ae-a5eb-9899515d0c28" class="">Languages</h2><ul id="d283fa0b-1672-4005-9e34-2fc69cd4148b" class="bulleted-list"><li>HLSL (High-Level Shading Language for Direct3D)</li></ul><ul id="dd986d57-c583-488d-a58e-03d3ee878309" class="bulleted-list"><li>GLSL (OpenGL Shading Language for OpenGL and OpenGL ES)</li></ul><ul id="807d0e60-7e3f-4611-b860-0b1d8102a21b" class="bulleted-list"><li>Metal (macOS, iOS)</li></ul><ul id="15e0da17-331c-45e2-9de6-11b2b105b475" class="bulleted-list"><li>SPIR-V (Standard, Portable Intermediate Representation from Vulkan)</li></ul><h1 id="7022f3b5-cf9b-4749-8c54-9601bf8e5186" class="">Data Types</h1><p id="3540feaa-3956-4a70-976d-7ad3e1f1f4cd" class="">GPUs natively support 32-bit integers, 32-bit and 64-bit floating point scalars and vectors.</p><p id="a0e82ed3-cbac-4cf5-999c-9f17cde9bdb6" class="">A vertex program has three type if input data:</p><ul id="3e826b21-0fd5-44ff-b621-f8762172bd53" class="bulleted-list"><li>uniform data remains constant through a draw call.</li></ul><ul id="74047272-7dcb-4aef-add2-4d0b755edff2" class="bulleted-list"><li>varying data comes from the vertex data or is interpolated by the rasterization stage.</li></ul><ul id="514fdd42-fdb2-497a-aff1-f383283ee327" class="bulleted-list"><li>resources are bind to a shader stage and can be read and written (texture can be sampled).</li></ul><h1 id="9bcfe467-1944-45c2-8f29-090339948399" class="">Functions</h1><p id="cfc7dace-2388-44a0-b718-638886344373" class="">Shader programs can perform common operations on their data types such as additions, multiplications, ...</p><p id="2db0664a-eb92-4218-be54-6d4b24a84ec2" class="">For other operations, such as math operations, they use intrinsic functions.</p><p id="974a3a34-c0c0-4203-ba23-be11fbcaabee" class="">Flow control is supported using two methods:</p><ul id="166b9e3b-15fe-4cb4-a6c7-a1939f6ec06f" class="bulleted-list"><li>Static flow branches that is constant during a draw call (based on the value of uniform inputs).</li></ul><ul id="3e478b87-195b-4a44-a2cb-d1bdf5e292fb" class="bulleted-list"><li>Dynamic flow branches that can create thread divergence (based on the value of varying inputs).</li></ul><p id="24c6bb7f-3e63-4b5b-b599-df607330c339" class="">Dynamic flow branches are more costly than static flow branches, as each shader program can execute code differently.</p><h1 id="d1f4ecab-0ccd-4f22-8c4a-f525e91f30a0" class="">Vertex Attributes</h1><p id="78eb0c25-a3d4-4d3a-bdaa-44d477f6277e" class="">Vertex shader can process vertex data in an arbitrary layout. To indicate how the data is setup, vertex attributes are defined.</p><p id="d32170d5-2cd3-4712-b602-71c666274ef4" class="">Each vertex attribute is defined by:</p><ul id="2f4d35a1-ba5b-4cca-8aa2-548fcb1327d9" class="bulleted-list"><li>A semantic to indicate the nature of the data (position, normal, tangent...)</li></ul><ul id="fb1d3044-3eae-434b-a100-9c4afec707d7" class="bulleted-list"><li>An offset</li></ul><ul id="2a116181-6104-4d49-a95d-2a7600d00dc7" class="bulleted-list"><li>An index</li></ul><h1 id="4236cd5d-1d75-4dd2-a66d-5b301b56b54c" class="">Vertex Data (Varying)</h1><p id="b0aee406-b1b2-4a3e-a467-44f910b12673" class="">Vertex data can be stored in multiple arrays.</p><p id="37940813-5468-4682-83e5-7376ad2e6326" class="">Each array is described by vertex attributes.</p><h2 id="34c016b2-72dd-4c89-90ea-be950a0e15a8" class="">Example</h2><p id="d4239eee-516c-4f3d-8b03-ced166e4ac3e" class="">One array can contain vertex positions and another vertex colors.</p><p id="2832389a-99e8-4662-9b34-55022fadd1a8" class="">Several objects can be rendered using the same vertex positions but distinct vertex colors.</p><h1 id="0a911129-e1c9-41dd-8e75-6105417de79f" class="">Constant Data (Uniform)</h1><p id="f1699963-9efa-4678-b380-5acee846113e" class="">In addition to vertex input data, constant data can be provided to the shader programs using uniform  buffers. Typically, information such as transform matrices, time values or other effects like fog parameters are passed to shader programs as constant data.</p><p id="e18e195e-67ea-4dec-9b7d-d5617f7f3339" class="">This data data is constant during a single frame, and it is typically separated into scene data that is shared by every renderer object such as the camera view transform matrix and object-specific data that is updated before rendering an object such as a model transform matrix.</p><p id="077b026c-571e-4414-a3c5-4cfcd98086f8" class="">When possible, data should be defined as SIMD types to match the memory layout and alignment of the GPU.</p><h1 id="5afcad7b-6b56-41ab-91fe-eac819ccd01a" class="">Shader Programs</h1><p id="dcecce82-2fd3-4cd4-abf8-8fe033ec5154" class="">Shaders are local functions.</p><p id="9206aecf-dfda-4b72-b8e9-3dcee6a8596c" class="">Most languages follow the C-style rules.</p><h1 id="7d2c614a-cfa6-478f-8dde-dea0c885f5d2" class="">Shader Stages</h1><p id="011af2f7-0444-409b-8b35-a5f9d8dde4ad" class="">Depending on the graphics pipeline, different kind of shaders are supported.</p><ul id="fbac5f46-daef-469f-b256-04c340576155" class="bulleted-list"><li>Vertex shaders - Operate on vertex data.</li></ul><ul id="e1809f12-ca55-4c2c-8dae-d80f3f491810" class="bulleted-list"><li>Tessellation control shaders - Operate on patch data.</li></ul><ul id="aacd57f5-f01c-4702-818e-bd2cd6ee2c1f" class="bulleted-list"><li>Tessellation evaluation shaders - Operate on primitive data.</li></ul><ul id="dcca2c45-63db-48fc-876a-ee8bb3f3b5ec" class="bulleted-list"><li>Geometry shaders - Operate on primitive data.</li></ul><ul id="040ef05b-8b95-42d7-ada2-ecda0d2ed938" class="bulleted-list"><li>Fragment shaders (or pixel shaders) - Operate on fragment data.</li></ul><ul id="d5325371-b778-4e45-b665-69f39ddf88ee" class="bulleted-list"><li>Compute shaders - Operate on any kind of data.</li></ul><h1 id="698035ad-eb4e-456b-b520-b526361d663a" class="">Vertex Shader</h1><p id="09bfd56f-e0ac-46eb-9948-71afbdd8763c" class="">This is a fully programmable shader stage.</p><p id="cd2b80c8-2ae7-4e2f-b551-e9a35d02a19b" class="">The main task of a vertex shader is to process incoming vertex data and map each vertex to a position in the viewport (clip-space coordinates).</p><p id="f6754a0d-202f-432f-991d-edb875fe30ba" class="">A vertex shader must at least output a vertex position.</p><p id="9ba5977f-60a8-4878-bd2f-3d45d0c539a1" class="">A vertex shader cannot add or remove vertices.</p><p id="f396dff9-9f4e-4873-8e56-a0aeeed8ce43" class="">The output of a vertex shader can be sent to different stages.</p><ul id="edfcf843-224b-4963-83af-b8c561039e3a" class="bulleted-list"><li>Rasterizer ‚Äì The vertices are interpolate and sent to the pixel shader stage.</li></ul><ul id="ffbd996a-2be4-4e09-b033-ef24fe5c4ec0" class="bulleted-list"><li>Tessellation ‚Äì The vertices are sent to the hull shader stage.</li></ul><ul id="6c0ddbd9-b37d-44fa-9661-57bda7f8c501" class="bulleted-list"><li>Geometry ‚Äì The vertices are sent to the geometry shader stage.</li></ul><h2 id="1a06651d-fb37-4612-a55d-e022ae43e4c4" class="">Examples</h2><ul id="bfd21627-a463-49c0-9442-7556b22d8c64" class="bulleted-list"><li>Vertex transformation (using a world-view-projection transform)</li></ul><ul id="1c96c353-2f89-48e5-8167-d879d5046e7e" class="bulleted-list"><li>Vertex animation (skinning and morphing)</li></ul><ul id="a9c7bcc4-47ad-4f58-9955-8f948feadf5c" class="bulleted-list"><li>Vertex deformation</li></ul><ul id="2b80046f-ad37-450f-8f0e-222984a47f50" class="bulleted-list"><li>Particle creation (by outputting degenerate meshes to a geometry shader)</li></ul><ul id="e25add08-54f8-4e9e-865b-1941a300143e" class="bulleted-list"><li>Screen distortion (by deforming the vertices of a screen-aligned quad)</li></ul><ul id="656e1d34-4cda-40c8-b0ae-04cc2f5f65fb" class="bulleted-list"><li>Terrain generation (based on a height-map)</li></ul><h1 id="5f87fc5a-2061-40a7-b060-bda90846a288" class="">Tessellation Shader</h1><p id="e733c1e6-66dd-4b31-90d1-d55aff1a36a2" class="">The tessellation stage can be used to render curved surfaces.</p><p id="028a8bfe-b44f-4813-bd67-7bdec5c3c131" class="">This is an optional stage.</p><p id="169f4f57-aaa7-41e3-9fe8-5a5a21a79951" class="">The level of detail can be controlled based on the distance of the object from the camera.</p><p id="315041a6-af6b-4010-9320-b272f04059f0" class="">The tessellation stage consists itself of three stages:</p><ul id="1e3290ff-0820-4ae8-b001-1cd74f1b1e39" class="bulleted-list"><li>Control<ul id="4a314b6d-b385-4cfe-b07f-354286225c4b" class="bulleted-list"><li>Tessellation control in OpenGL and Vulkan</li></ul><ul id="4bfec963-2ed6-4667-987e-175a66f30c9d" class="bulleted-list"><li>Hull shader in DirectX</li></ul><ul id="1397c966-630e-4ade-8550-733872e061f7" class="bulleted-list"><li>Compute kernel function in Metal</li></ul></li></ul><ul id="5e1909cc-a723-497b-9e53-87a5e096287e" class="bulleted-list"><li>Tessellator<ul id="a91ec062-ef7a-4234-aa24-95eb276f88e0" class="bulleted-list"><li>Primitive generator in OpenGL and Vulkan</li></ul><ul id="7d15cb63-b0b8-420d-9c0a-3b0b3733391b" class="bulleted-list"><li>Tessellator in DirectX and Metal</li></ul></li></ul><ul id="4e7a5a93-5f74-4d2c-b200-0396de3c7a3b" class="bulleted-list"><li>Evaluation<ul id="84f2c2c3-cfb3-4cd2-9ee0-69bce5a117b6" class="bulleted-list"><li>Tessellation evaluation in OpenGL and Vulkan</li></ul><ul id="8013d26c-98c9-4bf4-a13c-b326bf2a3557" class="bulleted-list"><li>Domain shader in DirectX</li></ul><ul id="c7a4c105-2912-4394-a2a7-0bc92f40490c" class="bulleted-list"><li>Post-tessellation function in Metal</li></ul></li></ul><p id="033fdddb-931a-4de1-94a8-32a238ef7914" class="">The control stage and the evaluation stage are programmable stages.</p><p id="d28de767-b125-483c-b010-f10147bd8366" class="">The tessellator is a fixed-function stage.</p><h2 id="3c834536-86bf-4d5a-b185-011f9f3fce05" class="">Control</h2><p id="d5e1c905-90d1-4179-963a-f56734335c44" class="">The input of the control stage is a patch primitive.</p><p id="08eb9df4-5c18-4db5-bc25-0ab78af418ca" class="">A patch primitive consists of several control points defining a subdivision surface or B√©zier curve.</p><p id="a230c8e2-2363-4e3d-803b-a493538c9ecc" class="">The control stage has two functions:</p><ul id="98bd8dbe-56ca-4d15-bb25-342b2295cc86" class="bulleted-list"><li>Specify how many triangles should be generated, and the type of the tessellation surface.</li></ul><ul id="d9a20e0c-fdbf-4711-a17c-373967ceae4b" class="bulleted-list"><li>Optionally modify the incoming patch by adding or removing control points.</li></ul><p id="33230bd5-8f77-4431-9aa4-d0d65667cbe0" class="">The different types of tessellation surface are:</p><ul id="5762f8cb-30dd-4da2-9da0-76c9edc2175a" class="bulleted-list"><li>Triangle</li></ul><ul id="f18ba41b-2409-41b4-b1d7-20b4105fc7fd" class="bulleted-list"><li>Quadrilateral (or quads)</li></ul><ul id="28e45735-90a0-46e8-9b0a-13bd95ee3321" class="bulleted-list"><li>Isoline ‚Äì Sets of line strips (usually used for rendering hair).</li></ul><p id="a2a98808-8535-48dc-bd3d-76fd21109ec5" class="">The tessellation factors (known as tessellation levels in OpenGL and Vulkan) have two types:</p><ul id="5326b82e-61fa-475d-bacd-da5163714685" class="bulleted-list"><li>Inner edge ‚Äì Indicate how much tessellation occurs inside the surface.</li></ul><ul id="3b594c10-044f-45d4-a93b-35b257d9b953" class="bulleted-list"><li>Outer edge ‚Äì Determine how the edges are split.</li></ul><p id="a78a1a70-2ef7-4668-9593-61602ccc5ba4" class="">The tessellation factors and the type of of the tessellation surface are sent to the tessellator and evaluation stage.</p><p id="c67f0f0e-b403-491b-a7e7-a561836a2b45" class="">The control points of the transformed patch are sent to the evaluation stage.</p><p id="352307ab-aaa2-4c8d-be8c-2ea9f87cceef" class="">The control shader can discard a patch.</p><h2 id="e4c66fe1-c05d-4360-9659-64a560ed025b" class="">Tessellator</h2><p id="9ea7b2a0-8f84-4fd7-b440-87fcbe11b05d" class="">The tessellator generates a set of vertices with their barycentric coordinates (relative locations on the surface).</p><p id="076c3059-b841-4c46-ac95-db292d0a10f9" class="">The points are sent to the evaluation stage.</p><h2 id="0271c876-bd06-4f0e-856a-7e778885c88e" class="">Evaluation</h2><p id="073b9e30-53f0-413a-8492-9d5b43f4de7e" class="">The evaluation stage processes the vertices from the tessellator using the control points to generate the output values for the vertices.</p><p id="ec472b8d-69de-4013-921c-e63d0aef70f7" class="">The generated triangles are sent to the rasterizer stage or the geometry shader stage.</p><h1 id="05d032d4-3704-468a-ba0f-ac167e01dffc" class="">Geometry Shader</h1><p id="540c5f0f-f45a-495b-b594-b08b2502f5fa" class="">The geometry shader can transform primitives into other type of primitives.</p><p id="5c65fa95-e8ea-4b4f-920d-692352d9e126" class="">Geometry shaders modify input data and can duplicate it.</p><p id="91ee27bc-9988-41b1-87bf-21f8e68551a9" class="">This is an optional and fully programmable shader stage.</p><p id="1cebfb74-6558-4315-888d-9d1139434719" class="">The geometry shader process points, lines or triangles and can process extended primitives that contain adjacent vertices on polyline.</p><p id="31dff3f4-eb3d-4ca9-bf2b-f0924ab4d5fb" class="">Geometry shaders can also process patches, but the tessellator is more efficient.</p><p id="031e200d-01f5-44b4-b342-b2c2a33cbfa9" class="">Geometry shaders support instancing.</p><p id="8140e966-8e8d-4a48-b8bf-12deb3a230cc" class="">The processed vertices of a geometry shader are sent to the rasterizer stage.</p><p id="db087bef-6e5e-46a2-a7dd-69e8e9dfc7a1" class="">Optionally, the vertices can be written to an <em>output stream</em> (<em>transform feedback</em> in OpenGL) to be sent back through the pipeline.</p><p id="111bc2fa-d172-465a-9744-1f84e895207e" class="">This functionality can be used to simulate particles, but it is costly as the data is stored in floating point numbers.</p><h2 id="147633bd-92fc-4dc5-9014-4ab8d12d5d8a" class="">Examples</h2><ul id="55fabfff-6ba4-48ac-b2ae-734dcc5f4785" class="bulleted-list"><li>Wireframe view by transforming triangles into edges.</li></ul><ul id="17a4a912-4f44-42ce-9fbc-ba42df0ad903" class="bulleted-list"><li>Render six faces of a cubemap.</li></ul><ul id="0189544c-9f6c-4eed-9b2b-387901e99ac8" class="bulleted-list"><li>Create cascaded shadow maps.</li></ul><ul id="b7d382e8-7ad4-4f3a-8ed9-9d03845270fb" class="bulleted-list"><li>Variable-sized particles.</li></ul><ul id="8a640ae9-6f0c-443b-986b-881d29daafdc" class="bulleted-list"><li>Fur rendering by extruding fins along silhouettes.</li></ul><ul id="6b34ce77-455c-41d3-931f-5cdd82d5c834" class="bulleted-list"><li>Metaball isosurface tessellation.</li></ul><ul id="95f8220e-c754-475d-b652-5d7bfff2cebc" class="bulleted-list"><li>Fractal subdivision of line segments.</li></ul><ul id="9c592371-d157-49bc-a714-f923db30d3fc" class="bulleted-list"><li>Cloth simulation.</li></ul><h1 id="0dcee714-78f6-4c9a-b5d3-b01ffa77cf71" class="">Fragment Shader</h1><p id="4ab30607-717f-4103-b34f-4a2013d719fe" class="">The fragment shader is known as <em>pixel shader</em> in DirectX.</p><p id="e8e49865-ac4b-4861-9c65-d8eed04a2a35" class="">This is a fully programmable shader stage.</p><p id="a6a2f75c-f7b6-411d-8423-ac9e1f59ba9f" class="">The rasterizer stage interpolates the vertex data and sends it to the fragment shader stage.</p><p id="e1b49fce-e406-45ec-8790-3974e962f975" class="">The default interpolation is a perspective-correct interpolation but the type of interpolation can be changed (for example, screen-space interpolation in which perspective projection is ignored).</p><p id="eab90b05-adf0-44a2-9a31-606293e511a7" class="">A fragment is the piece of a triangle that comes from the rasterizer.</p><p id="8b653c28-4735-4943-8764-b048331ba2b5" class="">The main task of a fragment shader is to process incoming fragment data and calculate a color value for the final pixels.</p><p id="a04df78e-a29a-4f56-9f27-9000b4bb27a9" class="">The fragment shader can also output an opacity value and a depth value.</p><p id="dd3cb130-eee5-46d4-aa93-fefd029dfeed" class="">The color value and depth value are then written to the color buffer and depth buffer.</p><p id="68934ba7-9dfa-45ef-bbe4-d8d0c41fe5e9" class="">The default depth value comes from the rasterizer, but can be overridden by a fragment shader.</p><p id="5c3a47b4-6d45-4e33-88af-4a55f40400b5" class="">In the merge stage, the output from the fragment shader can be used to produce different effects, by testing the current values in the depth buffer and stencil buffer.</p><h1 id="f7df1557-fca6-459f-a93b-6dcb6f68ba20" class="">Computer Shader</h1><p id="362b4a07-710a-4ec0-b403-d05106503d1a" class="">The GPU can be used for any kind of processing task and isn‚Äôt limited to graphics.</p><p id="919e24b3-9e36-47b2-9c54-74150fcb8f06" class="">This is called general-purpose GPU (GPGPU) programming.</p><p id="23ea9aa0-0a66-4c7f-a40a-560a26af98cd" class="">The compute processing pipeline is made up of a programmable kernel function, that executes a compute pass and reads from and writes to resources directly.</p><h3 id="8f9d58b6-e99a-49fb-8ad0-0b2df4f35e90" class="">Thread groups</h3><p id="a31c9b76-8bfd-4c0d-bb21-f85ae5be4887" class="">In order to execute in parallel, each workload must be broken apart into thread groups.</p><p id="94da9fbc-7248-4714-95c0-c9fdf0d7cf7b" class="">A compute pass must specify the number of times to execute a kernel function. Threads are organized into a 3D grid and this number corresponds to the grid size.</p><p id="f47ea998-c3e9-4e75-95cf-00c51519713e" class="">Each thread group has s small amount of memory that is shared among threads.</p><p id="b465e7f7-2415-48e3-a675-badcbcd878ba" class="">For example, for processing a 2D image, each thread corresponds to a unique texel, and the grid size must be at least the size of the image.</p><p id="d4933ad2-d3e2-424d-b0f1-680dd732e595" class="">The thread execution width is the number of threads that can be scheduled to run concurrently on the GPU (usually a power of two). Selecting an efficient thread group size depends on both the size of the data and the capabilities of a specific device. To make the most efficient use of the GPU, the total number of items in a thread group should be a multiple of the thread execution width.</p><h2 id="f081cf64-15de-4af4-ba17-765dfd0a0229" class="">Examples</h2><ul id="99f16f6c-9124-4e8d-807c-d60892a292dc" class="bulleted-list"><li>Compute the luminance of an image.</li></ul><ul id="0fe63f57-c612-4c09-aeab-76d7e436cf30" class="bulleted-list"><li>Particle simulations.</li></ul><ul id="e4d94f77-6df0-4cea-b439-0090242a64dc" class="bulleted-list"><li>Facial animation.</li></ul><ul id="cdfc21e9-a3a1-4084-b351-d21e925e7be6" class="bulleted-list"><li>Mesh culling.</li></ul><ul id="9ab59524-7213-43c5-bb2d-993eef668985" class="bulleted-list"><li>Image filtering.</li></ul></div></article></body></html>